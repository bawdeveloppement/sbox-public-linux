// <auto-generated>
// This file was generated by a tool.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class SandboxToolsInteropAssetSystemInternal
{
	public static int Convert( Type t )
	{
		if ( typeof( global::Editor.BaseScrollWidget ).IsAssignableFrom( t ) ) return 256245278;
		if ( typeof( global::Editor.Button ).IsAssignableFrom( t ) ) return 2120449044;
		if ( typeof( global::Editor.Checkbox ).IsAssignableFrom( t ) ) return 772888385;
		if ( typeof( global::Editor.ComboBox ).IsAssignableFrom( t ) ) return 256233403;
		if ( typeof( global::Editor.Frame ).IsAssignableFrom( t ) ) return 416267623;
		if ( typeof( global::Editor.GraphicsView ).IsAssignableFrom( t ) ) return 774054386;
		if ( typeof( global::Editor.Label ).IsAssignableFrom( t ) ) return -1333028724;
		if ( typeof( global::Editor.LineEdit ).IsAssignableFrom( t ) ) return -2137430376;
		if ( typeof( global::Editor.MenuBar ).IsAssignableFrom( t ) ) return -1325607872;
		if ( typeof( global::Editor.StatusBar ).IsAssignableFrom( t ) ) return -1890426169;
		if ( typeof( global::Editor.TextEdit ).IsAssignableFrom( t ) ) return 1008106499;
		if ( typeof( global::Editor.ToolBar ).IsAssignableFrom( t ) ) return -2124457813;
		if ( typeof( global::Editor.Window ).IsAssignableFrom( t ) ) return -1571505210;
		if ( typeof( global::Editor.DockManager ).IsAssignableFrom( t ) ) return -2135796158;
		if ( typeof( global::Editor.GraphicsItem ).IsAssignableFrom( t ) ) return 2109064242;
		if ( typeof( global::Editor.GraphicsScene ).IsAssignableFrom( t ) ) return -735098127;
		if ( typeof( global::Editor.GraphicsWidget ).IsAssignableFrom( t ) ) return -120989933;
		if ( typeof( global::Editor.Option ).IsAssignableFrom( t ) ) return 780535505;
		if ( typeof( global::Editor.TrayIcon ).IsAssignableFrom( t ) ) return 1020660495;
		if ( typeof( global::Editor.Widget ).IsAssignableFrom( t ) ) return 323741830;
		
		throw new System.Exception( $"Can't handle type {t}" );
	}
}
internal unsafe partial struct AssetPickedWrapper
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( AssetPickedWrapper value ) => value.self;
	static public implicit operator AssetPickedWrapper( IntPtr value ) => new AssetPickedWrapper { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( AssetPickedWrapper c1, AssetPickedWrapper c2 ) => c1.self == c2.self;
	public static bool operator !=( AssetPickedWrapper c1, AssetPickedWrapper c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is AssetPickedWrapper c && c == this;
	
	internal AssetPickedWrapper( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"AssetPickedWrapper {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"AssetPickedWrapper was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void DeleteThis() { NullCheck(); __N.sstPckdWrppr_DeleteThis( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static global::AssetPickedWrapper Create() { if ( __N.sstPckdWrppr_Create == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.sstPckdWrppr_Create(); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void AddAsset( global::IAsset asset ) { NullCheck(); __N.sstPckdWrppr_AddAsset( self, asset ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, void > sstPckdWrppr_DeleteThis;
		internal static delegate* unmanaged< IntPtr > sstPckdWrppr_Create;
		internal static delegate* unmanaged< IntPtr, IntPtr, void > sstPckdWrppr_AddAsset;
	}
}

internal unsafe partial struct CResourceStream
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( CResourceStream value ) => value.self;
	static public implicit operator CResourceStream( IntPtr value ) => new CResourceStream { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( CResourceStream c1, CResourceStream c2 ) => c1.self == c2.self;
	public static bool operator !=( CResourceStream c1, CResourceStream c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is CResourceStream c && c == this;
	
	internal CResourceStream( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"CResourceStream {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CResourceStream was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void WriteBytes( IntPtr data, int size ) { NullCheck(); __N.CResourceStream_WriteBytes( self, data, size ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void Align( int alignment, int offset ) { NullCheck(); __N.CResourceStream_Align( self, alignment, offset ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void AlignPointer() { NullCheck(); __N.CResourceStream_AlignPointer( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly uint Tell() { NullCheck(); return __N.CResourceStream_Tell( self ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, IntPtr, int, void > CResourceStream_WriteBytes;
		internal static delegate* unmanaged< IntPtr, int, int, void > CResourceStream_Align;
		internal static delegate* unmanaged< IntPtr, void > CResourceStream_AlignPointer;
		internal static delegate* unmanaged< IntPtr, uint > CResourceStream_Tell;
	}
}

namespace NativeEngine
{
	internal unsafe partial struct CUtlVectorAsset
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CUtlVectorAsset value ) => value.self;
		static public implicit operator CUtlVectorAsset( IntPtr value ) => new CUtlVectorAsset { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CUtlVectorAsset c1, CUtlVectorAsset c2 ) => c1.self == c2.self;
		public static bool operator !=( CUtlVectorAsset c1, CUtlVectorAsset c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CUtlVectorAsset c && c == this;
		
		internal CUtlVectorAsset( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CUtlVectorAsset {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CUtlVectorAsset was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DeleteThis() { NullCheck(); __N.CtlVctrsst_DeleteThis( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal static global::NativeEngine.CUtlVectorAsset Create( int growsize, int initialcapacity ) { if ( __N.CtlVctrsst_Create == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.CtlVctrsst_Create( growsize, initialcapacity ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int Count() { NullCheck(); return __N.CtlVctrsst_Count( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::IAsset Element( int i ) { NullCheck(); return __N.CtlVctrsst_Element( self, i ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, void > CtlVctrsst_DeleteThis;
			internal static delegate* unmanaged< int, int, IntPtr > CtlVctrsst_Create;
			internal static delegate* unmanaged< IntPtr, int > CtlVctrsst_Count;
			internal static delegate* unmanaged< IntPtr, int, IntPtr > CtlVctrsst_Element;
		}
	}
}

namespace NativeEngine
{
	internal unsafe partial struct CUtlVectorAssetType
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CUtlVectorAssetType value ) => value.self;
		static public implicit operator CUtlVectorAssetType( IntPtr value ) => new CUtlVectorAssetType { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CUtlVectorAssetType c1, CUtlVectorAssetType c2 ) => c1.self == c2.self;
		public static bool operator !=( CUtlVectorAssetType c1, CUtlVectorAssetType c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CUtlVectorAssetType c && c == this;
		
		internal CUtlVectorAssetType( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CUtlVectorAssetType {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CUtlVectorAssetType was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DeleteThis() { NullCheck(); __N.CtlVctrsstTyp_DeleteThis( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal static global::NativeEngine.CUtlVectorAssetType Create( int growsize, int initialcapacity ) { if ( __N.CtlVctrsstTyp_Create == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.CtlVctrsstTyp_Create( growsize, initialcapacity ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int Count() { NullCheck(); return __N.CtlVctrsstTyp_Count( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::IAssetType Element( int i ) { NullCheck(); return __N.CtlVctrsstTyp_Element( self, i ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, void > CtlVctrsstTyp_DeleteThis;
			internal static delegate* unmanaged< int, int, IntPtr > CtlVctrsstTyp_Create;
			internal static delegate* unmanaged< IntPtr, int > CtlVctrsstTyp_Count;
			internal static delegate* unmanaged< IntPtr, int, IntPtr > CtlVctrsstTyp_Element;
		}
	}
}

internal unsafe static partial class IAssetPreviewSystem
{
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static bool RenderAssetThumbnail( global::IAsset pAsset, global::Native.QPixmap targetPixmap ) { if ( __N.g_psstPrvwSystm_RenderAssetThumbnail == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.g_psstPrvwSystm_RenderAssetThumbnail( pAsset, targetPixmap ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static void OnThumbnailGenerated( global::IAsset asset, global::Native.QPixmap renderedPixmap ) { if ( __N.g_psstPrvwSystm_OnThumbnailGenerated == null ) throw new System.Exception( "Function Pointer Is Null" );__N.g_psstPrvwSystm_OnThumbnailGenerated( asset, renderedPixmap ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static global::NativeEngine.IModel GetModelForAsset( global::IAsset pAsset ) { if ( __N.g_psstPrvwSystm_GetModelForAsset == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.g_psstPrvwSystm_GetModelForAsset( pAsset ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, IntPtr, int > g_psstPrvwSystm_RenderAssetThumbnail;
		internal static delegate* unmanaged< IntPtr, IntPtr, void > g_psstPrvwSystm_OnThumbnailGenerated;
		internal static delegate* unmanaged< IntPtr, IntPtr > g_psstPrvwSystm_GetModelForAsset;
	}
}

internal unsafe static partial class IAssetSystem
{
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static void RecordAssetOpen( global::IAsset pAsset ) { if ( __N.g_pAssetSystem_RecordAssetOpen == null ) throw new System.Exception( "Function Pointer Is Null" );__N.g_pAssetSystem_RecordAssetOpen( pAsset ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static void RecordAssetOpen( string pAssetFileName ) { if ( __N.g_pAssetSystem_RecordAssetOpen_1 == null ) throw new System.Exception( "Function Pointer Is Null" );var _str_pAssetFileName = new Sandbox.Interop.InteropString( pAssetFileName ); try { __N.g_pAssetSystem_RecordAssetOpen_1( _str_pAssetFileName.Pointer ); } finally { _str_pAssetFileName.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static global::IAsset FindAssetByFilename( string pFilename ) { if ( __N.g_pAssetSystem_FindAssetByFilename == null ) throw new System.Exception( "Function Pointer Is Null" );var _str_pFilename = new Sandbox.Interop.InteropString( pFilename ); try { return __N.g_pAssetSystem_FindAssetByFilename( _str_pFilename.Pointer ); } finally { _str_pFilename.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static global::IAsset FindAssetByAssetRelativePath( string pFilename ) { if ( __N.g_pAssetSystem_FindAssetByAssetRelativePath == null ) throw new System.Exception( "Function Pointer Is Null" );var _str_pFilename = new Sandbox.Interop.InteropString( pFilename ); try { return __N.g_pAssetSystem_FindAssetByAssetRelativePath( _str_pFilename.Pointer ); } finally { _str_pFilename.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static global::IAsset RegisterAssetFile( string pFilename ) { if ( __N.g_pAssetSystem_RegisterAssetFile == null ) throw new System.Exception( "Function Pointer Is Null" );var _str_pFilename = new Sandbox.Interop.InteropString( pFilename ); try { return __N.g_pAssetSystem_RegisterAssetFile( _str_pFilename.Pointer ); } finally { _str_pFilename.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static void RunFrame() { if ( __N.g_pAssetSystem_RunFrame == null ) throw new System.Exception( "Function Pointer Is Null" );__N.g_pAssetSystem_RunFrame(); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static void UpdateMods() { if ( __N.g_pAssetSystem_UpdateMods == null ) throw new System.Exception( "Function Pointer Is Null" );__N.g_pAssetSystem_UpdateMods(); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static int GetAllModsCount() { if ( __N.g_pAssetSystem_GetAllModsCount == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.g_pAssetSystem_GetAllModsCount(); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static bool RecompileAsset( global::IAsset asset, bool full ) { if ( __N.g_pAssetSystem_RecompileAsset == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.g_pAssetSystem_RecompileAsset( asset, full ? 1 : 0 ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static void UpdateGameResourceType( string title, string extension ) { if ( __N.g_pAssetSystem_UpdateGameResourceType == null ) throw new System.Exception( "Function Pointer Is Null" );var _str_extension = new Sandbox.Interop.InteropString( extension ); try { var _str_title = new Sandbox.Interop.InteropString( title ); try { __N.g_pAssetSystem_UpdateGameResourceType( _str_title.Pointer, _str_extension.Pointer ); } finally { _str_title.Free(); }  } finally { _str_extension.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal static void LoadWorkingSetsAndTags() { if ( __N.g_pAssetSystem_LoadWorkingSetsAndTags == null ) throw new System.Exception( "Function Pointer Is Null" );__N.g_pAssetSystem_LoadWorkingSetsAndTags(); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, void > g_pAssetSystem_RecordAssetOpen;
		internal static delegate* unmanaged< IntPtr, void > g_pAssetSystem_RecordAssetOpen_1;
		internal static delegate* unmanaged< IntPtr, IntPtr > g_pAssetSystem_FindAssetByFilename;
		internal static delegate* unmanaged< IntPtr, IntPtr > g_pAssetSystem_FindAssetByAssetRelativePath;
		internal static delegate* unmanaged< IntPtr, IntPtr > g_pAssetSystem_RegisterAssetFile;
		internal static delegate* unmanaged< void > g_pAssetSystem_RunFrame;
		internal static delegate* unmanaged< void > g_pAssetSystem_UpdateMods;
		internal static delegate* unmanaged< int > g_pAssetSystem_GetAllModsCount;
		internal static delegate* unmanaged< IntPtr, int, int > g_pAssetSystem_RecompileAsset;
		internal static delegate* unmanaged< IntPtr, IntPtr, void > g_pAssetSystem_UpdateGameResourceType;
		internal static delegate* unmanaged< void > g_pAssetSystem_LoadWorkingSetsAndTags;
	}
}

internal unsafe partial struct IAsset
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( IAsset value ) => value.self;
	static public implicit operator IAsset( IntPtr value ) => new IAsset { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( IAsset c1, IAsset c2 ) => c1.self == c2.self;
	public static bool operator !=( IAsset c1, IAsset c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is IAsset c && c == this;
	
	internal IAsset( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"IAsset {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"IAsset was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetFriendlyName_Transient() { NullCheck(); return Sandbox.Interop.GetString( __N.IAsset_GetFriendlyName_Transient( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetRelativePath_Transient( AssetLocation_t source ) { NullCheck(); return Sandbox.Interop.GetString( __N.IAsset_GetRelativePath_Transient( self, (long)(source) ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetAbsolutePath_Transient( AssetLocation_t source ) { NullCheck(); return Sandbox.Interop.GetString( __N.IAsset_GetAbsolutePath_Transient( self, (long)(source) ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool HasAnyFiles() { NullCheck(); return __N.IAsset_HasAnyFiles( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool IsCached() { NullCheck(); return __N.IAsset_IsCached( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool CanReload() { NullCheck(); return __N.IAsset_CanReload( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool CanRecompile() { NullCheck(); return __N.IAsset_CanRecompile( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly uint GetAssetIndexInt() { NullCheck(); return __N.IAsset_GetAssetIndexInt( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool OpenInTool() { NullCheck(); return __N.IAsset_OpenInTool( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool OpenInSecondaryTool( string tool ) { NullCheck(); var _str_tool = new Sandbox.Interop.InteropString( tool ); try { return __N.IAsset_OpenInSecondaryTool( self, _str_tool.Pointer ) != 0; } finally { _str_tool.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void GetAssetsIDependOn( global::NativeEngine.CUtlVectorAsset pOutAssetsIDependOn, bool bDeep ) { NullCheck(); __N.IAsset_GetAssetsIDependOn( self, pOutAssetsIDependOn, bDeep ? 1 : 0 ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void GetAssetsIParent( global::NativeEngine.CUtlVectorAsset pOutChildren, bool bDeep ) { NullCheck(); __N.IAsset_GetAssetsIParent( self, pOutChildren, bDeep ? 1 : 0 ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void GetAssetsIReference( global::NativeEngine.CUtlVectorAsset pOutReferencers, bool bDeep ) { NullCheck(); __N.IAsset_GetAssetsIReference( self, pOutReferencers, bDeep ? 1 : 0 ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void GetAssetsDependingOnMe( global::NativeEngine.CUtlVectorAsset pOutDependencies, bool bDeep ) { NullCheck(); __N.IAsset_GetAssetsDependingOnMe( self, pOutDependencies, bDeep ? 1 : 0 ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void GetAssetsReferencingMe( global::NativeEngine.CUtlVectorAsset pOutReferencers, bool bDeep ) { NullCheck(); __N.IAsset_GetAssetsReferencingMe( self, pOutReferencers, bDeep ? 1 : 0 ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void GetAssetsParentingMe( global::NativeEngine.CUtlVectorAsset pOutParents, bool bDeep ) { NullCheck(); __N.IAsset_GetAssetsParentingMe( self, pOutParents, bDeep ? 1 : 0 ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly int AdditionalRelatedFileCount() { NullCheck(); return __N.IAsset_AdditionalRelatedFileCount( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly int AdditionalInputDependencyCount() { NullCheck(); return __N.IAsset_AdditionalInputDependencyCount( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetAdditionalRelatedFile_Transient( int nIndex ) { NullCheck(); return Sandbox.Interop.GetString( __N.IAsset_GetAdditionalRelatedFile_Transient( self, nIndex ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetAdditionalInputDependency_Transient( int nIndex ) { NullCheck(); return Sandbox.Interop.GetString( __N.IAsset_GetAdditionalInputDependency_Transient( self, nIndex ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void GetUnrecognizedRelatedPaths( AssetRelatedPathType_t filterType, global::NativeEngine.CUtlVectorString paths ) { NullCheck(); __N.IAsset_GetUnrecognizedRelatedPaths( self, (long)(filterType), paths ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void RequireDependencyInfo_Virtual() { NullCheck(); __N.IAsset_RequireDependencyInfo_Virtual( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool NeedAnyDependencyUpdate_Virtual() { NullCheck(); return __N.IAsset_NeedAnyDependencyUpdate_Virtual( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool IsTrivialChildAsset() { NullCheck(); return __N.IAsset_IsTrivialChildAsset( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool HasHiddenAssetFlag() { NullCheck(); return __N.IAsset_HasHiddenAssetFlag( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly int GetAssetTypeId() { NullCheck(); return __N.IAsset_GetAssetTypeId( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void CacheAsset( bool bIsBlocking ) { NullCheck(); __N.IAsset_CacheAsset( self, bIsBlocking ? 1 : 0 ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void UncacheAsset() { NullCheck(); __N.IAsset_UncacheAsset( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool HasSourceFile() { NullCheck(); return __N.IAsset_HasSourceFile( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool HasCompiledFile() { NullCheck(); return __N.IAsset_HasCompiledFile( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool IsCompiled() { NullCheck(); return __N.IAsset_IsCompiled( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool IsCompiledAndUpToDate() { NullCheck(); return __N.IAsset_IsCompiledAndUpToDate( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool IsCompileFailed() { NullCheck(); return __N.IAsset_IsCompileFailed( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool CompileIfNeeded() { NullCheck(); return __N.IAsset_CompileIfNeeded( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly int FindIntEditInfo( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { return __N.IAsset_FindIntEditInfo( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string FindStringEditInfo( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { return Sandbox.Interop.GetString( __N.IAsset_FindStringEditInfo( self, _str_name.Pointer ) ); } finally { _str_name.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetCompileStateReason_Transient() { NullCheck(); return Sandbox.Interop.GetString( __N.IAsset_GetCompileStateReason_Transient( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool SetInMemoryReplacement( string data ) { NullCheck(); var _str_data = new Sandbox.Interop.InteropString( data ); try { return __N.IAsset_SetInMemoryReplacement( self, _str_data.Pointer ) != 0; } finally { _str_data.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void DiscardInMemoryReplacement() { NullCheck(); __N.IAsset_DiscardInMemoryReplacement( self ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, IntPtr > IAsset_GetFriendlyName_Transient;
		internal static delegate* unmanaged< IntPtr, long, IntPtr > IAsset_GetRelativePath_Transient;
		internal static delegate* unmanaged< IntPtr, long, IntPtr > IAsset_GetAbsolutePath_Transient;
		internal static delegate* unmanaged< IntPtr, int > IAsset_HasAnyFiles;
		internal static delegate* unmanaged< IntPtr, int > IAsset_IsCached;
		internal static delegate* unmanaged< IntPtr, int > IAsset_CanReload;
		internal static delegate* unmanaged< IntPtr, int > IAsset_CanRecompile;
		internal static delegate* unmanaged< IntPtr, uint > IAsset_GetAssetIndexInt;
		internal static delegate* unmanaged< IntPtr, int > IAsset_OpenInTool;
		internal static delegate* unmanaged< IntPtr, IntPtr, int > IAsset_OpenInSecondaryTool;
		internal static delegate* unmanaged< IntPtr, IntPtr, int, void > IAsset_GetAssetsIDependOn;
		internal static delegate* unmanaged< IntPtr, IntPtr, int, void > IAsset_GetAssetsIParent;
		internal static delegate* unmanaged< IntPtr, IntPtr, int, void > IAsset_GetAssetsIReference;
		internal static delegate* unmanaged< IntPtr, IntPtr, int, void > IAsset_GetAssetsDependingOnMe;
		internal static delegate* unmanaged< IntPtr, IntPtr, int, void > IAsset_GetAssetsReferencingMe;
		internal static delegate* unmanaged< IntPtr, IntPtr, int, void > IAsset_GetAssetsParentingMe;
		internal static delegate* unmanaged< IntPtr, int > IAsset_AdditionalRelatedFileCount;
		internal static delegate* unmanaged< IntPtr, int > IAsset_AdditionalInputDependencyCount;
		internal static delegate* unmanaged< IntPtr, int, IntPtr > IAsset_GetAdditionalRelatedFile_Transient;
		internal static delegate* unmanaged< IntPtr, int, IntPtr > IAsset_GetAdditionalInputDependency_Transient;
		internal static delegate* unmanaged< IntPtr, long, IntPtr, void > IAsset_GetUnrecognizedRelatedPaths;
		internal static delegate* unmanaged< IntPtr, void > IAsset_RequireDependencyInfo_Virtual;
		internal static delegate* unmanaged< IntPtr, int > IAsset_NeedAnyDependencyUpdate_Virtual;
		internal static delegate* unmanaged< IntPtr, int > IAsset_IsTrivialChildAsset;
		internal static delegate* unmanaged< IntPtr, int > IAsset_HasHiddenAssetFlag;
		internal static delegate* unmanaged< IntPtr, int > IAsset_GetAssetTypeId;
		internal static delegate* unmanaged< IntPtr, int, void > IAsset_CacheAsset;
		internal static delegate* unmanaged< IntPtr, void > IAsset_UncacheAsset;
		internal static delegate* unmanaged< IntPtr, int > IAsset_HasSourceFile;
		internal static delegate* unmanaged< IntPtr, int > IAsset_HasCompiledFile;
		internal static delegate* unmanaged< IntPtr, int > IAsset_IsCompiled;
		internal static delegate* unmanaged< IntPtr, int > IAsset_IsCompiledAndUpToDate;
		internal static delegate* unmanaged< IntPtr, int > IAsset_IsCompileFailed;
		internal static delegate* unmanaged< IntPtr, int > IAsset_CompileIfNeeded;
		internal static delegate* unmanaged< IntPtr, IntPtr, int > IAsset_FindIntEditInfo;
		internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr > IAsset_FindStringEditInfo;
		internal static delegate* unmanaged< IntPtr, IntPtr > IAsset_GetCompileStateReason_Transient;
		internal static delegate* unmanaged< IntPtr, IntPtr, int > IAsset_SetInMemoryReplacement;
		internal static delegate* unmanaged< IntPtr, void > IAsset_DiscardInMemoryReplacement;
	}
}

internal unsafe partial struct IAssetPickerListener
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( IAssetPickerListener value ) => value.self;
	static public implicit operator IAssetPickerListener( IntPtr value ) => new IAssetPickerListener { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( IAssetPickerListener c1, IAssetPickerListener c2 ) => c1.self == c2.self;
	public static bool operator !=( IAssetPickerListener c1, IAssetPickerListener c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is IAssetPickerListener c && c == this;
	
	internal IAssetPickerListener( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"IAssetPickerListener {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"IAssetPickerListener was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NotifyAssetPicked( global::AssetPickedWrapper wrapper ) { NullCheck(); __N.sstPckrLstnr_NotifyAssetPicked( self, wrapper ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, IntPtr, void > sstPckrLstnr_NotifyAssetPicked;
	}
}

internal unsafe partial struct IAssetType
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( IAssetType value ) => value.self;
	static public implicit operator IAssetType( IntPtr value ) => new IAssetType { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( IAssetType c1, IAssetType c2 ) => c1.self == c2.self;
	public static bool operator !=( IAssetType c1, IAssetType c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is IAssetType c && c == this;
	
	internal IAssetType( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"IAssetType {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"IAssetType was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetFriendlyName() { NullCheck(); return Sandbox.Interop.GetString( __N.IAssetType_GetFriendlyName( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetIconLg() { NullCheck(); return Sandbox.Interop.GetString( __N.IAssetType_GetIconLg( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetIconSm() { NullCheck(); return Sandbox.Interop.GetString( __N.IAssetType_GetIconSm( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetPrimaryExtension() { NullCheck(); return Sandbox.Interop.GetString( __N.IAssetType_GetPrimaryExtension( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetColor() { NullCheck(); return Sandbox.Interop.GetString( __N.IAssetType_GetColor( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetCategory() { NullCheck(); return Sandbox.Interop.GetString( __N.IAssetType_GetCategory( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool HideTypeByDefault() { NullCheck(); return __N.IAssetType_HideTypeByDefault( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool IgnoreCompiledState() { NullCheck(); return __N.IAssetType_IgnoreCompiledState( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool IsContentFileText() { NullCheck(); return __N.IAssetType_IsContentFileText( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool IsSimpleAsset() { NullCheck(); return __N.IAssetType_IsSimpleAsset( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool HasDependencies() { NullCheck(); return __N.IAssetType_HasDependencies( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool PrefersIconForThumbnail() { NullCheck(); return __N.IAssetType_PrefersIconForThumbnail( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string GetAssetTypeName() { NullCheck(); return Sandbox.Interop.GetString( __N.IAssetType_GetAssetTypeName( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void GetAdditionalExtensions( global::NativeEngine.CUtlVectorString pExts ) { NullCheck(); __N.IAssetType_GetAdditionalExtensions( self, pExts ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, IntPtr > IAssetType_GetFriendlyName;
		internal static delegate* unmanaged< IntPtr, IntPtr > IAssetType_GetIconLg;
		internal static delegate* unmanaged< IntPtr, IntPtr > IAssetType_GetIconSm;
		internal static delegate* unmanaged< IntPtr, IntPtr > IAssetType_GetPrimaryExtension;
		internal static delegate* unmanaged< IntPtr, IntPtr > IAssetType_GetColor;
		internal static delegate* unmanaged< IntPtr, IntPtr > IAssetType_GetCategory;
		internal static delegate* unmanaged< IntPtr, int > IAssetType_HideTypeByDefault;
		internal static delegate* unmanaged< IntPtr, int > IAssetType_IgnoreCompiledState;
		internal static delegate* unmanaged< IntPtr, int > IAssetType_IsContentFileText;
		internal static delegate* unmanaged< IntPtr, int > IAssetType_IsSimpleAsset;
		internal static delegate* unmanaged< IntPtr, int > IAssetType_HasDependencies;
		internal static delegate* unmanaged< IntPtr, int > IAssetType_PrefersIconForThumbnail;
		internal static delegate* unmanaged< IntPtr, IntPtr > IAssetType_GetAssetTypeName;
		internal static delegate* unmanaged< IntPtr, IntPtr, void > IAssetType_GetAdditionalExtensions;
	}
}

internal unsafe partial struct IResourceCompilerContext
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( IResourceCompilerContext value ) => value.self;
	static public implicit operator IResourceCompilerContext( IntPtr value ) => new IResourceCompilerContext { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( IResourceCompilerContext c1, IResourceCompilerContext c2 ) => c1.self == c2.self;
	public static bool operator !=( IResourceCompilerContext c1, IResourceCompilerContext c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is IResourceCompilerContext c && c == this;
	
	internal IResourceCompilerContext( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"IResourceCompilerContext {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"IResourceCompilerContext was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void SetExtension( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.RsrcCmplrCntxt_SetExtension( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void SetCompiler( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.RsrcCmplrCntxt_SetCompiler( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string FullPath() { NullCheck(); return Sandbox.Interop.GetString( __N.RsrcCmplrCntxt_FullPath( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string RelativePath() { NullCheck(); return Sandbox.Interop.GetString( __N.RsrcCmplrCntxt_RelativePath( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly string ResourceName() { NullCheck(); return Sandbox.Interop.GetString( __N.RsrcCmplrCntxt_ResourceName( self ) ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void SpecifyResourceVersion( int nVersion ) { NullCheck(); __N.RsrcCmplrCntxt_SpecifyResourceVersion( self, nVersion ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void RegisterSpecialDependency( string str, uint nUserData, uint nFingerprint ) { NullCheck(); var _str_str = new Sandbox.Interop.InteropString( str ); try { __N.RsrcCmplrCntxt_RegisterSpecialDependency( self, _str_str.Pointer, nUserData, nFingerprint ); } finally { _str_str.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool RegisterReference( string filename ) { NullCheck(); var _str_filename = new Sandbox.Interop.InteropString( filename ); try { return __N.RsrcCmplrCntxt_RegisterReference( self, _str_filename.Pointer ) != 0; } finally { _str_filename.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void RegisterInputFileDependency( string filename, int flags ) { NullCheck(); var _str_filename = new Sandbox.Interop.InteropString( filename ); try { __N.RsrcCmplrCntxt_RegisterInputFileDependency( self, _str_filename.Pointer, flags ); } finally { _str_filename.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly int WriteBlock( string blockName, IntPtr data, int count ) { NullCheck(); var _str_blockName = new Sandbox.Interop.InteropString( blockName ); try { return __N.RsrcCmplrCntxt_WriteBlock( self, _str_blockName.Pointer, data, count ); } finally { _str_blockName.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly global::CUtlBuffer GetOverrideData() { NullCheck(); return __N.RsrcCmplrCntxt_GetOverrideData( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly global::CResourceStream Data() { NullCheck(); return __N.RsrcCmplrCntxt_Data( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly global::CResourceStream StreamingData() { NullCheck(); return __N.RsrcCmplrCntxt_StreamingData( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly global::IResourceCompilerContextChild CreateChildContext( string pFileName ) { NullCheck(); var _str_pFileName = new Sandbox.Interop.InteropString( pFileName ); try { return __N.RsrcCmplrCntxt_CreateChildContext( self, _str_pFileName.Pointer ); } finally { _str_pFileName.Free(); }  }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, IntPtr, void > RsrcCmplrCntxt_SetExtension;
		internal static delegate* unmanaged< IntPtr, IntPtr, void > RsrcCmplrCntxt_SetCompiler;
		internal static delegate* unmanaged< IntPtr, IntPtr > RsrcCmplrCntxt_FullPath;
		internal static delegate* unmanaged< IntPtr, IntPtr > RsrcCmplrCntxt_RelativePath;
		internal static delegate* unmanaged< IntPtr, IntPtr > RsrcCmplrCntxt_ResourceName;
		internal static delegate* unmanaged< IntPtr, int, void > RsrcCmplrCntxt_SpecifyResourceVersion;
		internal static delegate* unmanaged< IntPtr, IntPtr, uint, uint, void > RsrcCmplrCntxt_RegisterSpecialDependency;
		internal static delegate* unmanaged< IntPtr, IntPtr, int > RsrcCmplrCntxt_RegisterReference;
		internal static delegate* unmanaged< IntPtr, IntPtr, int, void > RsrcCmplrCntxt_RegisterInputFileDependency;
		internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, int, int > RsrcCmplrCntxt_WriteBlock;
		internal static delegate* unmanaged< IntPtr, IntPtr > RsrcCmplrCntxt_GetOverrideData;
		internal static delegate* unmanaged< IntPtr, IntPtr > RsrcCmplrCntxt_Data;
		internal static delegate* unmanaged< IntPtr, IntPtr > RsrcCmplrCntxt_StreamingData;
		internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr > RsrcCmplrCntxt_CreateChildContext;
	}
}

internal unsafe partial struct IResourceCompilerContextChild
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( IResourceCompilerContextChild value ) => value.self;
	static public implicit operator IResourceCompilerContextChild( IntPtr value ) => new IResourceCompilerContextChild { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( IResourceCompilerContextChild c1, IResourceCompilerContextChild c2 ) => c1.self == c2.self;
	public static bool operator !=( IResourceCompilerContextChild c1, IResourceCompilerContextChild c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is IResourceCompilerContextChild c && c == this;
	
	internal IResourceCompilerContextChild( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"IResourceCompilerContextChild {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"IResourceCompilerContextChild was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void SetOverrideInputData( string data ) { NullCheck(); var _str_data = new Sandbox.Interop.InteropString( data ); try { __N.RsrcCmplrCntxtCh_SetOverrideInputData( self, _str_data.Pointer ); } finally { _str_data.Free(); }  }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool CompileImmediately() { NullCheck(); return __N.RsrcCmplrCntxtCh_CompileImmediately( self ) != 0; }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, IntPtr, void > RsrcCmplrCntxtCh_SetOverrideInputData;
		internal static delegate* unmanaged< IntPtr, int > RsrcCmplrCntxtCh_CompileImmediately;
	}
}

namespace Managed.SourceAssetSytem
{
	internal static unsafe class Exports
	{
		/// <summary>
		/// Editor.AssetSystem.PreInitialize( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_PreInitialize()
		{
			try
			{
				Editor.AssetSystem.PreInitialize();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "PreInitialize", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.AssetAdded( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_AssetAdded( IntPtr asset )
		{
			try
			{
				Editor.AssetSystem.AssetAdded( asset );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "AssetAdded", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.AssetRemoved( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_AssetRemoved( uint index )
		{
			try
			{
				Editor.AssetSystem.AssetRemoved( index );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "AssetRemoved", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.AssetChanged( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_AssetChanged( uint index )
		{
			try
			{
				Editor.AssetSystem.AssetChanged( index );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "AssetChanged", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.UpdateAssetAutoTags( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_UpdateAssetAutoTags( uint index )
		{
			try
			{
				Editor.AssetSystem.UpdateAssetAutoTags( index );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "UpdateAssetAutoTags", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.RecordAssetOpen( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_RecordAssetOpen( uint index )
		{
			try
			{
				Editor.AssetSystem.RecordAssetOpen( index );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "RecordAssetOpen", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.AssetScanComplete( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_AssetScanComplete()
		{
			try
			{
				Editor.AssetSystem.AssetScanComplete();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "AssetScanComplete", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.RegisterAssetType( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_RegisterAssetType( int none, IntPtr assetType )
		{
			try
			{
				Editor.AssetSystem.RegisterAssetType( none, assetType );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "RegisterAssetType", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.InitializeCompilerForFilename( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_InitializeCompilerForFilename( IntPtr context, IntPtr filename )
		{
			try
			{
				Editor.AssetSystem.InitializeCompilerForFilename( context, Sandbox.Interop.GetString( filename ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "InitializeCompilerForFilename", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.TryManagedCompile( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int Editor_AssetSystem_TryManagedCompile( IntPtr context )
		{
			try
			{
				return Editor.AssetSystem.TryManagedCompile( context ) ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "TryManagedCompile", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.OnSoundReload( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_OnSoundReload( IntPtr filename )
		{
			try
			{
				Editor.AssetSystem.OnSoundReload( Sandbox.Interop.GetString( filename ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "OnSoundReload", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.OnSoundReloaded( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_OnSoundReloaded( IntPtr filename )
		{
			try
			{
				Editor.AssetSystem.OnSoundReloaded( Sandbox.Interop.GetString( filename ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "OnSoundReloaded", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.OnDemandRecompile( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_OnDemandRecompile( uint index, IntPtr reason )
		{
			try
			{
				Editor.AssetSystem.OnDemandRecompile( index, Sandbox.Interop.GetString( reason ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "OnDemandRecompile", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.OpenPicker( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_OpenPicker( IntPtr pParentWidget, IntPtr assetTypes, IntPtr callback, int viewmode, IntPtr selectedAsset, IntPtr titleAndSettingsName, int cloudAllowed, IntPtr initialSearchText )
		{
			try
			{
				Editor.AssetSystem.OpenPicker( pParentWidget, assetTypes, callback, viewmode, selectedAsset, Sandbox.Interop.GetString( titleAndSettingsName ), cloudAllowed != 0, Sandbox.Interop.GetString( initialSearchText ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "OpenPicker", ___e );
			}
		}
		
		/// <summary>
		/// Editor.AssetSystem.PopulateAssetMenu( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void Editor_AssetSystem_PopulateAssetMenu( IntPtr qMenu, IntPtr asset )
		{
			try
			{
				Editor.AssetSystem.PopulateAssetMenu( qMenu, asset );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.AssetSystem", "PopulateAssetMenu", ___e );
			}
		}
		
	}
	
	internal unsafe static partial class NativeInterop
	{
		static IntPtr _nativeLibraryHandle;
		static bool _initialized;
		
		[UnmanagedFunctionPointer( CallingConvention.Cdecl )]
		internal delegate void _ErrorFunction( string message );
		
		[UnmanagedFunctionPointer( CallingConvention.Cdecl )]
		delegate void NetCoreImportDelegate( int hash, void* imports, void* exports, int* structSizes );
		
		internal static void Initialize()
		{
			if ( _initialized ) return;
			
			if ( !NativeLibrary.TryLoad( System.IO.Path.Combine( NetCore.NativeDllPath, "libassetsystem.so" ), out var nativeDll ) )
				Sandbox.Interop.NativeAssemblyLoadFailed( "libassetsystem.so" );
			_nativeLibraryHandle = nativeDll;
			NetCoreImportDelegate nativeInit = default;
			
			IntPtr nativeInitPtr = NativeLibrary.GetExport( nativeDll, "igen_assetsystem" );
			if ( nativeInitPtr == IntPtr.Zero )
			
			{
				throw new System.Exception( "Couldn't load from libassetsystem.so - igen_assetsystem not found." );
			}
			
			nativeInit = Marshal.GetDelegateForFunctionPointer<NetCoreImportDelegate>( nativeInitPtr );
			if ( nativeInit == null ) throw new System.Exception( "Couldn't load from libassetsystem.so" );
			
			var managedFunctions = new IntPtr[15]
			
			{
				(IntPtr) (delegate* unmanaged<void>) &Exports.Editor_AssetSystem_PreInitialize,
				(IntPtr) (delegate* unmanaged<IntPtr, void>) &Exports.Editor_AssetSystem_AssetAdded,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.Editor_AssetSystem_AssetRemoved,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.Editor_AssetSystem_AssetChanged,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.Editor_AssetSystem_UpdateAssetAutoTags,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.Editor_AssetSystem_RecordAssetOpen,
				(IntPtr) (delegate* unmanaged<void>) &Exports.Editor_AssetSystem_AssetScanComplete,
				(IntPtr) (delegate* unmanaged<int, IntPtr, void>) &Exports.Editor_AssetSystem_RegisterAssetType,
				(IntPtr) (delegate* unmanaged<IntPtr, IntPtr, void>) &Exports.Editor_AssetSystem_InitializeCompilerForFilename,
				(IntPtr) (delegate* unmanaged<IntPtr, int>) &Exports.Editor_AssetSystem_TryManagedCompile,
				(IntPtr) (delegate* unmanaged<IntPtr, void>) &Exports.Editor_AssetSystem_OnSoundReload,
				(IntPtr) (delegate* unmanaged<IntPtr, void>) &Exports.Editor_AssetSystem_OnSoundReloaded,
				(IntPtr) (delegate* unmanaged<uint, IntPtr, void>) &Exports.Editor_AssetSystem_OnDemandRecompile,
				(IntPtr) (delegate* unmanaged<IntPtr, IntPtr, IntPtr, int, IntPtr, IntPtr, int, IntPtr, void>) &Exports.Editor_AssetSystem_OpenPicker,
				(IntPtr) (delegate* unmanaged<IntPtr, IntPtr, void>) &Exports.Editor_AssetSystem_PopulateAssetMenu,
			};
			
			var nativeFunctions = new IntPtr[100];
			
			var structSizes = new int[]
			
			{
				sizeof( AssetLocation_t ),
				sizeof( AssetRelatedPathType_t ),
			};
			
			
			fixed ( void* m = managedFunctions )
			fixed ( void* n = nativeFunctions )
			fixed ( int* s = structSizes )
			
			{
				nativeInit( 50924, m, n, s );
			}
			
			var onError = Marshal.GetDelegateForFunctionPointer<_ErrorFunction>( nativeFunctions[0] );
			
			try
			{
				AssetPickedWrapper.__N.sstPckdWrppr_DeleteThis = (delegate* unmanaged< IntPtr, void >) nativeFunctions[1];
				AssetPickedWrapper.__N.sstPckdWrppr_Create = (delegate* unmanaged< IntPtr >) nativeFunctions[2];
				AssetPickedWrapper.__N.sstPckdWrppr_AddAsset = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[3];
				CResourceStream.__N.CResourceStream_WriteBytes = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[4];
				CResourceStream.__N.CResourceStream_Align = (delegate* unmanaged< IntPtr, int, int, void >) nativeFunctions[5];
				CResourceStream.__N.CResourceStream_AlignPointer = (delegate* unmanaged< IntPtr, void >) nativeFunctions[6];
				CResourceStream.__N.CResourceStream_Tell = (delegate* unmanaged< IntPtr, uint >) nativeFunctions[7];
				NativeEngine.CUtlVectorAsset.__N.CtlVctrsst_DeleteThis = (delegate* unmanaged< IntPtr, void >) nativeFunctions[8];
				NativeEngine.CUtlVectorAsset.__N.CtlVctrsst_Create = (delegate* unmanaged< int, int, IntPtr >) nativeFunctions[9];
				NativeEngine.CUtlVectorAsset.__N.CtlVctrsst_Count = (delegate* unmanaged< IntPtr, int >) nativeFunctions[10];
				NativeEngine.CUtlVectorAsset.__N.CtlVctrsst_Element = (delegate* unmanaged< IntPtr, int, IntPtr >) nativeFunctions[11];
				NativeEngine.CUtlVectorAssetType.__N.CtlVctrsstTyp_DeleteThis = (delegate* unmanaged< IntPtr, void >) nativeFunctions[12];
				NativeEngine.CUtlVectorAssetType.__N.CtlVctrsstTyp_Create = (delegate* unmanaged< int, int, IntPtr >) nativeFunctions[13];
				NativeEngine.CUtlVectorAssetType.__N.CtlVctrsstTyp_Count = (delegate* unmanaged< IntPtr, int >) nativeFunctions[14];
				NativeEngine.CUtlVectorAssetType.__N.CtlVctrsstTyp_Element = (delegate* unmanaged< IntPtr, int, IntPtr >) nativeFunctions[15];
				IAssetPreviewSystem.__N.g_psstPrvwSystm_RenderAssetThumbnail = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[16];
				IAssetPreviewSystem.__N.g_psstPrvwSystm_OnThumbnailGenerated = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[17];
				IAssetPreviewSystem.__N.g_psstPrvwSystm_GetModelForAsset = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[18];
				IAssetSystem.__N.g_pAssetSystem_RecordAssetOpen = (delegate* unmanaged< IntPtr, void >) nativeFunctions[19];
				IAssetSystem.__N.g_pAssetSystem_RecordAssetOpen_1 = (delegate* unmanaged< IntPtr, void >) nativeFunctions[20];
				IAssetSystem.__N.g_pAssetSystem_FindAssetByFilename = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[21];
				IAssetSystem.__N.g_pAssetSystem_FindAssetByAssetRelativePath = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[22];
				IAssetSystem.__N.g_pAssetSystem_RegisterAssetFile = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[23];
				IAssetSystem.__N.g_pAssetSystem_RunFrame = (delegate* unmanaged< void >) nativeFunctions[24];
				IAssetSystem.__N.g_pAssetSystem_UpdateMods = (delegate* unmanaged< void >) nativeFunctions[25];
				IAssetSystem.__N.g_pAssetSystem_GetAllModsCount = (delegate* unmanaged< int >) nativeFunctions[26];
				IAssetSystem.__N.g_pAssetSystem_RecompileAsset = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[27];
				IAssetSystem.__N.g_pAssetSystem_UpdateGameResourceType = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[28];
				IAssetSystem.__N.g_pAssetSystem_LoadWorkingSetsAndTags = (delegate* unmanaged< void >) nativeFunctions[29];
				IAsset.__N.IAsset_GetFriendlyName_Transient = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[30];
				IAsset.__N.IAsset_GetRelativePath_Transient = (delegate* unmanaged< IntPtr, long, IntPtr >) nativeFunctions[31];
				IAsset.__N.IAsset_GetAbsolutePath_Transient = (delegate* unmanaged< IntPtr, long, IntPtr >) nativeFunctions[32];
				IAsset.__N.IAsset_HasAnyFiles = (delegate* unmanaged< IntPtr, int >) nativeFunctions[33];
				IAsset.__N.IAsset_IsCached = (delegate* unmanaged< IntPtr, int >) nativeFunctions[34];
				IAsset.__N.IAsset_CanReload = (delegate* unmanaged< IntPtr, int >) nativeFunctions[35];
				IAsset.__N.IAsset_CanRecompile = (delegate* unmanaged< IntPtr, int >) nativeFunctions[36];
				IAsset.__N.IAsset_GetAssetIndexInt = (delegate* unmanaged< IntPtr, uint >) nativeFunctions[37];
				IAsset.__N.IAsset_OpenInTool = (delegate* unmanaged< IntPtr, int >) nativeFunctions[38];
				IAsset.__N.IAsset_OpenInSecondaryTool = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[39];
				IAsset.__N.IAsset_GetAssetsIDependOn = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[40];
				IAsset.__N.IAsset_GetAssetsIParent = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[41];
				IAsset.__N.IAsset_GetAssetsIReference = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[42];
				IAsset.__N.IAsset_GetAssetsDependingOnMe = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[43];
				IAsset.__N.IAsset_GetAssetsReferencingMe = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[44];
				IAsset.__N.IAsset_GetAssetsParentingMe = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[45];
				IAsset.__N.IAsset_AdditionalRelatedFileCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[46];
				IAsset.__N.IAsset_AdditionalInputDependencyCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[47];
				IAsset.__N.IAsset_GetAdditionalRelatedFile_Transient = (delegate* unmanaged< IntPtr, int, IntPtr >) nativeFunctions[48];
				IAsset.__N.IAsset_GetAdditionalInputDependency_Transient = (delegate* unmanaged< IntPtr, int, IntPtr >) nativeFunctions[49];
				IAsset.__N.IAsset_GetUnrecognizedRelatedPaths = (delegate* unmanaged< IntPtr, long, IntPtr, void >) nativeFunctions[50];
				IAsset.__N.IAsset_RequireDependencyInfo_Virtual = (delegate* unmanaged< IntPtr, void >) nativeFunctions[51];
				IAsset.__N.IAsset_NeedAnyDependencyUpdate_Virtual = (delegate* unmanaged< IntPtr, int >) nativeFunctions[52];
				IAsset.__N.IAsset_IsTrivialChildAsset = (delegate* unmanaged< IntPtr, int >) nativeFunctions[53];
				IAsset.__N.IAsset_HasHiddenAssetFlag = (delegate* unmanaged< IntPtr, int >) nativeFunctions[54];
				IAsset.__N.IAsset_GetAssetTypeId = (delegate* unmanaged< IntPtr, int >) nativeFunctions[55];
				IAsset.__N.IAsset_CacheAsset = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[56];
				IAsset.__N.IAsset_UncacheAsset = (delegate* unmanaged< IntPtr, void >) nativeFunctions[57];
				IAsset.__N.IAsset_HasSourceFile = (delegate* unmanaged< IntPtr, int >) nativeFunctions[58];
				IAsset.__N.IAsset_HasCompiledFile = (delegate* unmanaged< IntPtr, int >) nativeFunctions[59];
				IAsset.__N.IAsset_IsCompiled = (delegate* unmanaged< IntPtr, int >) nativeFunctions[60];
				IAsset.__N.IAsset_IsCompiledAndUpToDate = (delegate* unmanaged< IntPtr, int >) nativeFunctions[61];
				IAsset.__N.IAsset_IsCompileFailed = (delegate* unmanaged< IntPtr, int >) nativeFunctions[62];
				IAsset.__N.IAsset_CompileIfNeeded = (delegate* unmanaged< IntPtr, int >) nativeFunctions[63];
				IAsset.__N.IAsset_FindIntEditInfo = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[64];
				IAsset.__N.IAsset_FindStringEditInfo = (delegate* unmanaged< IntPtr, IntPtr, IntPtr >) nativeFunctions[65];
				IAsset.__N.IAsset_GetCompileStateReason_Transient = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[66];
				IAsset.__N.IAsset_SetInMemoryReplacement = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[67];
				IAsset.__N.IAsset_DiscardInMemoryReplacement = (delegate* unmanaged< IntPtr, void >) nativeFunctions[68];
				IAssetPickerListener.__N.sstPckrLstnr_NotifyAssetPicked = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[69];
				IAssetType.__N.IAssetType_GetFriendlyName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[70];
				IAssetType.__N.IAssetType_GetIconLg = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[71];
				IAssetType.__N.IAssetType_GetIconSm = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[72];
				IAssetType.__N.IAssetType_GetPrimaryExtension = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[73];
				IAssetType.__N.IAssetType_GetColor = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[74];
				IAssetType.__N.IAssetType_GetCategory = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[75];
				IAssetType.__N.IAssetType_HideTypeByDefault = (delegate* unmanaged< IntPtr, int >) nativeFunctions[76];
				IAssetType.__N.IAssetType_IgnoreCompiledState = (delegate* unmanaged< IntPtr, int >) nativeFunctions[77];
				IAssetType.__N.IAssetType_IsContentFileText = (delegate* unmanaged< IntPtr, int >) nativeFunctions[78];
				IAssetType.__N.IAssetType_IsSimpleAsset = (delegate* unmanaged< IntPtr, int >) nativeFunctions[79];
				IAssetType.__N.IAssetType_HasDependencies = (delegate* unmanaged< IntPtr, int >) nativeFunctions[80];
				IAssetType.__N.IAssetType_PrefersIconForThumbnail = (delegate* unmanaged< IntPtr, int >) nativeFunctions[81];
				IAssetType.__N.IAssetType_GetAssetTypeName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[82];
				IAssetType.__N.IAssetType_GetAdditionalExtensions = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[83];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_SetExtension = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[84];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_SetCompiler = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[85];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_FullPath = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[86];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_RelativePath = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[87];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_ResourceName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[88];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_SpecifyResourceVersion = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[89];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_RegisterSpecialDependency = (delegate* unmanaged< IntPtr, IntPtr, uint, uint, void >) nativeFunctions[90];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_RegisterReference = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[91];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_RegisterInputFileDependency = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[92];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_WriteBlock = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, int, int >) nativeFunctions[93];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_GetOverrideData = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[94];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_Data = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[95];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_StreamingData = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[96];
				IResourceCompilerContext.__N.RsrcCmplrCntxt_CreateChildContext = (delegate* unmanaged< IntPtr, IntPtr, IntPtr >) nativeFunctions[97];
				IResourceCompilerContextChild.__N.RsrcCmplrCntxtCh_SetOverrideInputData = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[98];
				IResourceCompilerContextChild.__N.RsrcCmplrCntxtCh_CompileImmediately = (delegate* unmanaged< IntPtr, int >) nativeFunctions[99];
			}
			catch ( System.Exception ___e )
			{
				onError( $"{___e.Message}\n\n{___e.StackTrace}" );
			}
			_initialized = true;
		}
		internal static void Free()
		{
			if ( _nativeLibraryHandle == IntPtr.Zero ) return;
			NativeLibrary.Free( _nativeLibraryHandle );
			_nativeLibraryHandle = IntPtr.Zero;
			_initialized = false;
		}
	}
}
