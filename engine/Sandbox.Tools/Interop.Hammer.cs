// <auto-generated>
// This file was generated by a tool.
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class SandboxToolsInteropHammerInternal
{
	public static int Convert( Type t )
	{
		if ( typeof( global::Editor.BaseScrollWidget ).IsAssignableFrom( t ) ) return 256245278;
		if ( typeof( global::Editor.Button ).IsAssignableFrom( t ) ) return 2120449044;
		if ( typeof( global::Editor.Checkbox ).IsAssignableFrom( t ) ) return 772888385;
		if ( typeof( global::Editor.ComboBox ).IsAssignableFrom( t ) ) return 256233403;
		if ( typeof( global::Editor.Frame ).IsAssignableFrom( t ) ) return 416267623;
		if ( typeof( global::Editor.GraphicsView ).IsAssignableFrom( t ) ) return 774054386;
		if ( typeof( global::Editor.Label ).IsAssignableFrom( t ) ) return -1333028724;
		if ( typeof( global::Editor.LineEdit ).IsAssignableFrom( t ) ) return -2137430376;
		if ( typeof( global::Editor.MenuBar ).IsAssignableFrom( t ) ) return -1325607872;
		if ( typeof( global::Editor.StatusBar ).IsAssignableFrom( t ) ) return -1890426169;
		if ( typeof( global::Editor.TextEdit ).IsAssignableFrom( t ) ) return 1008106499;
		if ( typeof( global::Editor.ToolBar ).IsAssignableFrom( t ) ) return -2124457813;
		if ( typeof( global::Editor.Window ).IsAssignableFrom( t ) ) return -1571505210;
		if ( typeof( global::Editor.DockManager ).IsAssignableFrom( t ) ) return -2135796158;
		if ( typeof( global::Editor.GraphicsItem ).IsAssignableFrom( t ) ) return 2109064242;
		if ( typeof( global::Editor.GraphicsScene ).IsAssignableFrom( t ) ) return -735098127;
		if ( typeof( global::Editor.GraphicsWidget ).IsAssignableFrom( t ) ) return -120989933;
		if ( typeof( global::Editor.MapEditor.HammerMainWindow ).IsAssignableFrom( t ) ) return -1760060088;
		if ( typeof( global::Editor.MapEditor.HammerManagedInspector ).IsAssignableFrom( t ) ) return -2111160487;
		if ( typeof( global::Editor.MapEditor.HammerSession ).IsAssignableFrom( t ) ) return 886796921;
		if ( typeof( global::Editor.MapEditor.IEntityTool ).IsAssignableFrom( t ) ) return 389039275;
		if ( typeof( global::Editor.MapEditor.IPathTool ).IsAssignableFrom( t ) ) return -167448283;
		if ( typeof( global::Editor.Option ).IsAssignableFrom( t ) ) return 780535505;
		if ( typeof( global::Editor.TrayIcon ).IsAssignableFrom( t ) ) return 1020660495;
		if ( typeof( global::Editor.Widget ).IsAssignableFrom( t ) ) return 323741830;
		
		throw new System.Exception( $"Can't handle type {t}" );
	}
}
namespace NativeHammer
{
	internal unsafe partial struct CHammerApp
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CHammerApp value ) => value.self;
		static public implicit operator CHammerApp( IntPtr value ) => new CHammerApp { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CHammerApp c1, CHammerApp c2 ) => c1.self == c2.self;
		public static bool operator !=( CHammerApp c1, CHammerApp c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CHammerApp c && c == this;
		
		internal CHammerApp( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CHammerApp {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CHammerApp was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void RefreshEntitiesGameData() { NullCheck(); __N.CHammerApp_RefreshEntitiesGameData( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::NativeEngine.IMaterial GetCurrentMaterial() { NullCheck(); return __N.CHammerApp_GetCurrentMaterial( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetCurrentTexture( string assetFilename ) { NullCheck(); var _str_assetFilename = new Sandbox.Interop.InteropString( assetFilename ); try { __N.CHammerApp_SetCurrentTexture( self, _str_assetFilename.Pointer ); } finally { _str_assetFilename.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetActiveMapAsset() { NullCheck(); return __N.CHammerApp_GetActiveMapAsset( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetActiveMapDoc() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CHammerApp_GetActiveMapDoc( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkAllViewHudsDirty() { NullCheck(); __N.CHammerApp_MarkAllViewHudsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SelectObjectsUsingAsset( string assetFilename ) { NullCheck(); var _str_assetFilename = new Sandbox.Interop.InteropString( assetFilename ); try { __N.CHammerApp_SelectObjectsUsingAsset( self, _str_assetFilename.Pointer ); } finally { _str_assetFilename.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SelectFacesUsingMaterial( string assetFilename ) { NullCheck(); var _str_assetFilename = new Sandbox.Interop.InteropString( assetFilename ); try { __N.CHammerApp_SelectFacesUsingMaterial( self, _str_assetFilename.Pointer ); } finally { _str_assetFilename.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void AssignAssetToSelection( string assetFilename ) { NullCheck(); var _str_assetFilename = new Sandbox.Interop.InteropString( assetFilename ); try { __N.CHammerApp_AssignAssetToSelection( self, _str_assetFilename.Pointer ); } finally { _str_assetFilename.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void ShowEntityReportForAsset( string assetFilename ) { NullCheck(); var _str_assetFilename = new Sandbox.Interop.InteropString( assetFilename ); try { __N.CHammerApp_ShowEntityReportForAsset( self, _str_assetFilename.Pointer ); } finally { _str_assetFilename.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void OnFileReload() { NullCheck(); __N.CHammerApp_OnFileReload( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, void > CHammerApp_RefreshEntitiesGameData;
			internal static delegate* unmanaged< IntPtr, IntPtr > CHammerApp_GetCurrentMaterial;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CHammerApp_SetCurrentTexture;
			internal static delegate* unmanaged< IntPtr, int > CHammerApp_GetActiveMapAsset;
			internal static delegate* unmanaged< IntPtr, int > CHammerApp_GetActiveMapDoc;
			internal static delegate* unmanaged< IntPtr, void > CHammerApp_MarkAllViewHudsDirty;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CHammerApp_SelectObjectsUsingAsset;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CHammerApp_SelectFacesUsingMaterial;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CHammerApp_AssignAssetToSelection;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CHammerApp_ShowEntityReportForAsset;
			internal static delegate* unmanaged< IntPtr, void > CHammerApp_OnFileReload;
		}
	}
}

internal unsafe partial struct CHammerEditorSession
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( CHammerEditorSession value ) => value.self;
	static public implicit operator CHammerEditorSession( IntPtr value ) => new CHammerEditorSession { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( CHammerEditorSession c1, CHammerEditorSession c2 ) => c1.self == c2.self;
	public static bool operator !=( CHammerEditorSession c1, CHammerEditorSession c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is CHammerEditorSession c && c == this;
	
	internal CHammerEditorSession( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"CHammerEditorSession {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CHammerEditorSession was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void ShowLoadingProgressBar() { NullCheck(); __N.CHmmrdtrSssn_ShowLoadingProgressBar( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void HideLoadingProgressBar() { NullCheck(); __N.CHmmrdtrSssn_HideLoadingProgressBar( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly global::IAsset GetMapAsset() { NullCheck(); return __N.CHmmrdtrSssn_GetMapAsset( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly global::Editor.MapDoc.MapDocument GetMapDoc() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CHmmrdtrSssn_GetMapDoc( self ) ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, void > CHmmrdtrSssn_ShowLoadingProgressBar;
		internal static delegate* unmanaged< IntPtr, void > CHmmrdtrSssn_HideLoadingProgressBar;
		internal static delegate* unmanaged< IntPtr, IntPtr > CHmmrdtrSssn_GetMapAsset;
		internal static delegate* unmanaged< IntPtr, int > CHmmrdtrSssn_GetMapDoc;
	}
}

namespace NativeHammer
{
	internal unsafe partial struct CHistory
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CHistory value ) => value.self;
		static public implicit operator CHistory( IntPtr value ) => new CHistory { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CHistory c1, CHistory c2 ) => c1.self == c2.self;
		public static bool operator !=( CHistory c1, CHistory c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CHistory c && c == this;
		
		internal CHistory( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CHistory {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CHistory was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkUndoPosition( global::NativeMapDoc.CSelection pSelection, string pszName ) { NullCheck(); var _str_pszName = new Sandbox.Interop.InteropString( pszName ); try { __N.CHistory_MarkUndoPosition( self, pSelection, _str_pszName.Pointer ); } finally { _str_pszName.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Keep( global::Editor.MapDoc.MapNode pUndoable ) { NullCheck(); __N.CHistory_Keep( self, pUndoable == null ? IntPtr.Zero : pUndoable.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void KeepNew( global::Editor.MapDoc.MapNode pUndoable ) { NullCheck(); __N.CHistory_KeepNew( self, pUndoable == null ? IntPtr.Zero : pUndoable.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal static global::NativeHammer.CHistory GetHistory() { if ( __N.CHistory_GetHistory == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.CHistory_GetHistory(); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, void > CHistory_MarkUndoPosition;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CHistory_Keep;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CHistory_KeepNew;
			internal static delegate* unmanaged< IntPtr > CHistory_GetHistory;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapDoc
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapDoc value ) => value.self;
		static public implicit operator CMapDoc( IntPtr value ) => new CMapDoc { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapDoc c1, CMapDoc c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapDoc c1, CMapDoc c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapDoc c && c == this;
		
		internal CMapDoc( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapDoc {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapDoc was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetMapWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapDoc_GetMapWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetPathName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapDoc_GetPathName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::NativeMapDoc.CSelection GetSelection() { NullCheck(); return __N.CMapDoc_GetSelection( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void AddObjectToDocument( global::Editor.MapDoc.MapNode pObject, global::Editor.MapDoc.MapNode pParent ) { NullCheck(); __N.CMapDoc_AddObjectToDocument( self, pObject == null ? IntPtr.Zero : pObject.native, pParent == null ? IntPtr.Zero : pParent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DeleteObject( global::Editor.MapDoc.MapNode node ) { NullCheck(); __N.CMapDoc_DeleteObject( self, node == null ? IntPtr.Zero : node.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapMesh CreateEmptyMesh( bool addToDocument ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapMesh>( __N.CMapDoc_CreateEmptyMesh( self, addToDocument ? 1 : 0 ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity CreateEntity( bool addToDocument ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapDoc_CreateEntity( self, addToDocument ? 1 : 0 ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapGameObject CreateGameObject( bool addToDocument ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapGameObject>( __N.CMapDoc_CreateGameObject( self, addToDocument ? 1 : 0 ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CreateMapGroup() { NullCheck(); __N.CMapDoc_CreateMapGroup( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CreateMapInstance() { NullCheck(); __N.CMapDoc_CreateMapInstance( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CreateMapPath() { NullCheck(); __N.CMapDoc_CreateMapPath( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CreateStaticOverlay() { NullCheck(); __N.CMapDoc_CreateStaticOverlay( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, int > CMapDoc_GetMapWorld;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapDoc_GetPathName;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapDoc_GetSelection;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, void > CMapDoc_AddObjectToDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapDoc_DeleteObject;
			internal static delegate* unmanaged< IntPtr, int, int > CMapDoc_CreateEmptyMesh;
			internal static delegate* unmanaged< IntPtr, int, int > CMapDoc_CreateEntity;
			internal static delegate* unmanaged< IntPtr, int, int > CMapDoc_CreateGameObject;
			internal static delegate* unmanaged< IntPtr, void > CMapDoc_CreateMapGroup;
			internal static delegate* unmanaged< IntPtr, void > CMapDoc_CreateMapInstance;
			internal static delegate* unmanaged< IntPtr, void > CMapDoc_CreateMapPath;
			internal static delegate* unmanaged< IntPtr, void > CMapDoc_CreateStaticOverlay;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapEntity
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapEntity value ) => value.self;
		static public implicit operator CMapEntity( IntPtr value ) => new CMapEntity { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapEntity c1, CMapEntity c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapEntity c1, CMapEntity c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapEntity c && c == this;
		
		internal CMapEntity( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapEntity {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapEntity was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapNode( CMapEntity value ) => __N.To_CMapNode_From_CMapEntity( value );
		static public explicit operator CMapEntity( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapEntity( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetClassName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapEntity_GetClassName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetClass( string classname ) { NullCheck(); var _str_classname = new Sandbox.Interop.InteropString( classname ); try { __N.CMapEntity_SetClass( self, _str_classname.Pointer ); } finally { _str_classname.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetKeyValue( string key, string value ) { NullCheck(); var _str_value = new Sandbox.Interop.InteropString( value ); try { var _str_key = new Sandbox.Interop.InteropString( key ); try { __N.CMapEntity_SetKeyValue( self, _str_key.Pointer, _str_value.Pointer ); } finally { _str_key.Free(); }  } finally { _str_value.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetKeyValue( string key ) { NullCheck(); var _str_key = new Sandbox.Interop.InteropString( key ); try { return Sandbox.Interop.GetString( __N.CMapEntity_GetKeyValue( self, _str_key.Pointer ) ); } finally { _str_key.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool TargetNameMatches( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { return __N.CMapEntity_TargetNameMatches( self, _str_name.Pointer ) != 0; } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetDefaultBounds( Vector3 minBounds, Vector3 maxBounds ) { NullCheck(); __N.CMapEntity_SetDefaultBounds( self, &minBounds, &maxBounds ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapEntity_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapEntity_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapEntity_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapEntity_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapEntity_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapEntity_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapEntity_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapEntity_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapEntity_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapEntity_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapEntity_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapEntity_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapEntity_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapEntity_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapEntity_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapEntity_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapEntity_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapEntity_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapEntity_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapEntity_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapEntity_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapEntity_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapEntity_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapEntity_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapEntity_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapEntity_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapEntity_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapEntity_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapEntity_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapEntity_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapEntity_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapEntity_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapEntity_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapEntity;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapEntity;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapEntity_GetClassName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapEntity_SetClass;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, void > CMapEntity_SetKeyValue;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr > CMapEntity_GetKeyValue;
			internal static delegate* unmanaged< IntPtr, IntPtr, int > CMapEntity_TargetNameMatches;
			internal static delegate* unmanaged< IntPtr, Vector3*, Vector3*, void > CMapEntity_SetDefaultBounds;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapEntity_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapEntity_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapEntity_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapEntity_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapEntity_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapEntity_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapEntity_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapEntity_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapEntity_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapEntity_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapEntity_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapEntity_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapEntity_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapEntity_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapEntity_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapEntity_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapEntity_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapEntity_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapEntity_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapEntity_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapEntity_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapEntity_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapEntity_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapEntity_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapEntity_CoreAttributeChanged;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapGameObject
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapGameObject value ) => value.self;
		static public implicit operator CMapGameObject( IntPtr value ) => new CMapGameObject { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapGameObject c1, CMapGameObject c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapGameObject c1, CMapGameObject c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapGameObject c && c == this;
		
		internal CMapGameObject( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapGameObject {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapGameObject was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapNode( CMapGameObject value ) => __N.To_CMapNode_From_CMapGameObject( value );
		static public explicit operator CMapGameObject( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapGameObject( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetGUID( string json ) { NullCheck(); var _str_json = new Sandbox.Interop.InteropString( json ); try { __N.CMapGameObject_SetGUID( self, _str_json.Pointer ); } finally { _str_json.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetGUID() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapGameObject_GetGUID( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapGameObject_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapGameObject_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapGameObject_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGameObject_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapGameObject_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapGameObject_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapGameObject_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapGameObject_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapGameObject_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGameObject_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapGameObject_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapGameObject_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapGameObject_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapGameObject_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGameObject_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGameObject_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGameObject_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapGameObject_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapGameObject_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapGameObject_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapGameObject_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapGameObject_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapGameObject_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapGameObject_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapGameObject_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapGameObject_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapGameObject_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapGameObject_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapGameObject_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapGameObject_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapGameObject_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapGameObject_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapGameObject_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapGameObject;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapGameObject;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapGameObject_SetGUID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapGameObject_GetGUID;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapGameObject_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapGameObject_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapGameObject_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapGameObject_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapGameObject_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapGameObject_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapGameObject_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapGameObject_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapGameObject_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapGameObject_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapGameObject_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapGameObject_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapGameObject_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapGameObject_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapGameObject_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapGameObject_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapGameObject_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapGameObject_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapGameObject_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapGameObject_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapGameObject_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapGameObject_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapGameObject_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapGameObject_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapGameObject_CoreAttributeChanged;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapGroup
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapGroup value ) => value.self;
		static public implicit operator CMapGroup( IntPtr value ) => new CMapGroup { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapGroup c1, CMapGroup c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapGroup c1, CMapGroup c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapGroup c && c == this;
		
		internal CMapGroup( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapGroup {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapGroup was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapNode( CMapGroup value ) => __N.To_CMapNode_From_CMapGroup( value );
		static public explicit operator CMapGroup( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapGroup( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapGroup_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapGroup_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapGroup_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGroup_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapGroup_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapGroup_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapGroup_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapGroup_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapGroup_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGroup_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapGroup_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapGroup_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapGroup_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapGroup_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGroup_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGroup_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapGroup_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapGroup_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapGroup_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapGroup_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapGroup_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapGroup_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapGroup_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapGroup_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapGroup_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapGroup_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapGroup_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapGroup_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapGroup_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapGroup_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapGroup_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapGroup_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapGroup_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapGroup;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapGroup;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapGroup_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapGroup_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapGroup_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapGroup_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapGroup_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapGroup_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapGroup_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapGroup_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapGroup_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapGroup_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapGroup_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapGroup_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapGroup_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapGroup_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapGroup_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapGroup_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapGroup_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapGroup_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapGroup_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapGroup_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapGroup_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapGroup_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapGroup_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapGroup_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapGroup_CoreAttributeChanged;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapInstance
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapInstance value ) => value.self;
		static public implicit operator CMapInstance( IntPtr value ) => new CMapInstance { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapInstance c1, CMapInstance c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapInstance c1, CMapInstance c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapInstance c && c == this;
		
		internal CMapInstance( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapInstance {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapInstance was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapNode( CMapInstance value ) => __N.To_CMapNode_From_CMapInstance( value );
		static public explicit operator CMapInstance( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapInstance( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetTarget( global::Editor.MapDoc.MapNode node ) { NullCheck(); __N.CMapInstance_SetTarget( self, node == null ? IntPtr.Zero : node.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetTarget() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapInstance_GetTarget( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapInstance_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapInstance_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapInstance_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapInstance_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapInstance_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapInstance_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapInstance_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapInstance_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapInstance_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapInstance_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapInstance_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapInstance_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapInstance_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapInstance_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapInstance_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapInstance_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapInstance_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapInstance_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapInstance_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapInstance_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapInstance_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapInstance_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapInstance_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapInstance_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapInstance_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapInstance_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapInstance_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapInstance_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapInstance_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapInstance_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapInstance_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapInstance_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapInstance_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapInstance;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapInstance;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapInstance_SetTarget;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_GetTarget;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapInstance_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapInstance_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapInstance_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapInstance_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapInstance_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapInstance_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapInstance_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapInstance_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapInstance_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapInstance_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapInstance_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapInstance_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapInstance_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapInstance_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapInstance_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapInstance_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapInstance_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapInstance_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapInstance_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapInstance_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapInstance_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapInstance_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapInstance_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapInstance_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapInstance_CoreAttributeChanged;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapMesh
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapMesh value ) => value.self;
		static public implicit operator CMapMesh( IntPtr value ) => new CMapMesh { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapMesh c1, CMapMesh c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapMesh c1, CMapMesh c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapMesh c && c == this;
		
		internal CMapMesh( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapMesh {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapMesh was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapNode( CMapMesh value ) => __N.To_CMapNode_From_CMapMesh( value );
		static public explicit operator CMapMesh( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapMesh( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void AssignMaterialToMesh( string materialName ) { NullCheck(); var _str_materialName = new Sandbox.Interop.InteropString( materialName ); try { __N.CMapMesh_AssignMaterialToMesh( self, _str_materialName.Pointer ); } finally { _str_materialName.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void ConstructFromData( int numVerticies, IntPtr vertexPositions, IntPtr vertexTexCoords, int numIndices, IntPtr vertexIndices, int numFaces, IntPtr faceVertexCounts, IntPtr faceMaterialsPtr, bool mergeVertices, float vertexMergeTolerance ) { NullCheck(); __N.CMapMesh_ConstructFromData( self, numVerticies, vertexPositions, vertexTexCoords, numIndices, vertexIndices, numFaces, faceVertexCounts, faceMaterialsPtr, mergeVertices ? 1 : 0, vertexMergeTolerance ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void GetFaceMaterials( global::NativeEngine.CUtlVectorString materials ) { NullCheck(); __N.CMapMesh_GetFaceMaterials( self, materials ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapMesh_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapMesh_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapMesh_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapMesh_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapMesh_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapMesh_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapMesh_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapMesh_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapMesh_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapMesh_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapMesh_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapMesh_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapMesh_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapMesh_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapMesh_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapMesh_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapMesh_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapMesh_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapMesh_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapMesh_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapMesh_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapMesh_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapMesh_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapMesh_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapMesh_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapMesh_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapMesh_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapMesh_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapMesh_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapMesh_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapMesh_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapMesh_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapMesh_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapMesh;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapMesh;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapMesh_AssignMaterialToMesh;
			internal static delegate* unmanaged< IntPtr, int, IntPtr, IntPtr, int, IntPtr, int, IntPtr, IntPtr, int, float, void > CMapMesh_ConstructFromData;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapMesh_GetFaceMaterials;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapMesh_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapMesh_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapMesh_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapMesh_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapMesh_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapMesh_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapMesh_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapMesh_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapMesh_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapMesh_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapMesh_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapMesh_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapMesh_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapMesh_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapMesh_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapMesh_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapMesh_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapMesh_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapMesh_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapMesh_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapMesh_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapMesh_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapMesh_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapMesh_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapMesh_CoreAttributeChanged;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapNode
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapNode value ) => value.self;
		static public implicit operator CMapNode( IntPtr value ) => new CMapNode { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapNode c1, CMapNode c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapNode c1, CMapNode c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapNode c && c == this;
		
		internal CMapNode( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapNode {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapNode was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapNode_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapNode_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapNode_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapNode_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapNode_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapNode_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapNode_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapNode_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapNode_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapNode_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapNode_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapNode_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapNode_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapNode_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapNode_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapNode_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapNode_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapNode_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapNode_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapNode_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapNode_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapNode_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapNode_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapNode_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapNode_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapNode_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapNode_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapNode_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapNode_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapNode_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapNode_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapNode_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapNode_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, int > CMapNode_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapNode_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapNode_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapNode_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapNode_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapNode_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapNode_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapNode_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapNode_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapNode_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapNode_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapNode_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapNode_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapNode_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapNode_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapNode_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapNode_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapNode_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapNode_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapNode_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapNode_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapNode_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapNode_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapNode_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapNode_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapNode_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapNode_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapNode_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapNode_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapNode_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapNode_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapNode_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapNode_CoreAttributeChanged;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapPath
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapPath value ) => value.self;
		static public implicit operator CMapPath( IntPtr value ) => new CMapPath { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapPath c1, CMapPath c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapPath c1, CMapPath c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapPath c && c == this;
		
		internal CMapPath( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapPath {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapPath was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapEntity( CMapPath value ) => __N.To_CMapEntity_From_CMapPath( value );
		static public explicit operator CMapPath( NativeMapDoc.CMapEntity value ) => __N.From_CMapEntity_To_CMapPath( value );
		static public implicit operator NativeMapDoc.CMapNode( CMapPath value ) => __N.To_CMapNode_From_CMapPath( value );
		static public explicit operator CMapPath( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapPath( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapPathNode AddNewNodeToPath() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapPathNode>( __N.CMapPath_AddNewNodeToPath( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetClassName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapPath_GetClassName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetClass( string classname ) { NullCheck(); var _str_classname = new Sandbox.Interop.InteropString( classname ); try { __N.CMapPath_SetClass( self, _str_classname.Pointer ); } finally { _str_classname.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetKeyValue( string key, string value ) { NullCheck(); var _str_value = new Sandbox.Interop.InteropString( value ); try { var _str_key = new Sandbox.Interop.InteropString( key ); try { __N.CMapPath_SetKeyValue( self, _str_key.Pointer, _str_value.Pointer ); } finally { _str_key.Free(); }  } finally { _str_value.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetKeyValue( string key ) { NullCheck(); var _str_key = new Sandbox.Interop.InteropString( key ); try { return Sandbox.Interop.GetString( __N.CMapPath_GetKeyValue( self, _str_key.Pointer ) ); } finally { _str_key.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool TargetNameMatches( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { return __N.CMapPath_TargetNameMatches( self, _str_name.Pointer ) != 0; } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetDefaultBounds( Vector3 minBounds, Vector3 maxBounds ) { NullCheck(); __N.CMapPath_SetDefaultBounds( self, &minBounds, &maxBounds ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapPath_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapPath_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapPath_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPath_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapPath_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapPath_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapPath_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapPath_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapPath_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPath_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapPath_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapPath_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapPath_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapPath_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPath_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPath_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPath_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapPath_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapPath_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapPath_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapPath_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapPath_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapPath_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapPath_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapPath_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapPath_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapPath_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapPath_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapPath_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapPath_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapPath_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapPath_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapPath_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapEntity_To_CMapPath;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapEntity_From_CMapPath;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapPath;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapPath;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_AddNewNodeToPath;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapPath_GetClassName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapPath_SetClass;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, void > CMapPath_SetKeyValue;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr > CMapPath_GetKeyValue;
			internal static delegate* unmanaged< IntPtr, IntPtr, int > CMapPath_TargetNameMatches;
			internal static delegate* unmanaged< IntPtr, Vector3*, Vector3*, void > CMapPath_SetDefaultBounds;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapPath_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapPath_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapPath_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapPath_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapPath_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapPath_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapPath_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapPath_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapPath_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapPath_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapPath_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapPath_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapPath_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapPath_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapPath_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapPath_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapPath_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapPath_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapPath_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapPath_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapPath_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapPath_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapPath_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapPath_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapPath_CoreAttributeChanged;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapPathNode
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapPathNode value ) => value.self;
		static public implicit operator CMapPathNode( IntPtr value ) => new CMapPathNode { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapPathNode c1, CMapPathNode c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapPathNode c1, CMapPathNode c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapPathNode c && c == this;
		
		internal CMapPathNode( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapPathNode {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapPathNode was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapEntity( CMapPathNode value ) => __N.To_CMapEntity_From_CMapPathNode( value );
		static public explicit operator CMapPathNode( NativeMapDoc.CMapEntity value ) => __N.From_CMapEntity_To_CMapPathNode( value );
		static public implicit operator NativeMapDoc.CMapNode( CMapPathNode value ) => __N.To_CMapNode_From_CMapPathNode( value );
		static public explicit operator CMapPathNode( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapPathNode( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetClassName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapPathNode_GetClassName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetClass( string classname ) { NullCheck(); var _str_classname = new Sandbox.Interop.InteropString( classname ); try { __N.CMapPathNode_SetClass( self, _str_classname.Pointer ); } finally { _str_classname.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetKeyValue( string key, string value ) { NullCheck(); var _str_value = new Sandbox.Interop.InteropString( value ); try { var _str_key = new Sandbox.Interop.InteropString( key ); try { __N.CMapPathNode_SetKeyValue( self, _str_key.Pointer, _str_value.Pointer ); } finally { _str_key.Free(); }  } finally { _str_value.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetKeyValue( string key ) { NullCheck(); var _str_key = new Sandbox.Interop.InteropString( key ); try { return Sandbox.Interop.GetString( __N.CMapPathNode_GetKeyValue( self, _str_key.Pointer ) ); } finally { _str_key.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool TargetNameMatches( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { return __N.CMapPathNode_TargetNameMatches( self, _str_name.Pointer ) != 0; } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetDefaultBounds( Vector3 minBounds, Vector3 maxBounds ) { NullCheck(); __N.CMapPathNode_SetDefaultBounds( self, &minBounds, &maxBounds ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapPathNode_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapPathNode_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapPathNode_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPathNode_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapPathNode_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapPathNode_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapPathNode_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapPathNode_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapPathNode_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPathNode_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapPathNode_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapPathNode_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapPathNode_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapPathNode_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPathNode_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPathNode_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapPathNode_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapPathNode_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapPathNode_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapPathNode_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapPathNode_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapPathNode_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapPathNode_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapPathNode_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapPathNode_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapPathNode_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapPathNode_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapPathNode_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapPathNode_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapPathNode_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapPathNode_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapPathNode_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapPathNode_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapEntity_To_CMapPathNode;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapEntity_From_CMapPathNode;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapPathNode;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapPathNode;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapPathNode_GetClassName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapPathNode_SetClass;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, void > CMapPathNode_SetKeyValue;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr > CMapPathNode_GetKeyValue;
			internal static delegate* unmanaged< IntPtr, IntPtr, int > CMapPathNode_TargetNameMatches;
			internal static delegate* unmanaged< IntPtr, Vector3*, Vector3*, void > CMapPathNode_SetDefaultBounds;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapPathNode_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapPathNode_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapPathNode_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapPathNode_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapPathNode_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapPathNode_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapPathNode_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapPathNode_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapPathNode_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapPathNode_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapPathNode_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapPathNode_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapPathNode_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapPathNode_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapPathNode_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapPathNode_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapPathNode_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapPathNode_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapPathNode_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapPathNode_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapPathNode_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapPathNode_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapPathNode_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapPathNode_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapPathNode_CoreAttributeChanged;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapStaticOverlay
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapStaticOverlay value ) => value.self;
		static public implicit operator CMapStaticOverlay( IntPtr value ) => new CMapStaticOverlay { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapStaticOverlay c1, CMapStaticOverlay c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapStaticOverlay c1, CMapStaticOverlay c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapStaticOverlay c && c == this;
		
		internal CMapStaticOverlay( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapStaticOverlay {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapStaticOverlay was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapMesh( CMapStaticOverlay value ) => __N.To_CMapMesh_From_CMapStaticOverlay( value );
		static public explicit operator CMapStaticOverlay( NativeMapDoc.CMapMesh value ) => __N.From_CMapMesh_To_CMapStaticOverlay( value );
		static public implicit operator NativeMapDoc.CMapNode( CMapStaticOverlay value ) => __N.To_CMapNode_From_CMapStaticOverlay( value );
		static public explicit operator CMapStaticOverlay( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapStaticOverlay( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CreateCenteredQuad( float flWidth, float flHeight, string pMaterialName ) { NullCheck(); var _str_pMaterialName = new Sandbox.Interop.InteropString( pMaterialName ); try { __N.CMpSttcvrly_CreateCenteredQuad( self, flWidth, flHeight, _str_pMaterialName.Pointer ); } finally { _str_pMaterialName.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void AssignMaterialToMesh( string materialName ) { NullCheck(); var _str_materialName = new Sandbox.Interop.InteropString( materialName ); try { __N.CMpSttcvrly_AssignMaterialToMesh( self, _str_materialName.Pointer ); } finally { _str_materialName.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void ConstructFromData( int numVerticies, IntPtr vertexPositions, IntPtr vertexTexCoords, int numIndices, IntPtr vertexIndices, int numFaces, IntPtr faceVertexCounts, IntPtr faceMaterialsPtr, bool mergeVertices, float vertexMergeTolerance ) { NullCheck(); __N.CMpSttcvrly_ConstructFromData( self, numVerticies, vertexPositions, vertexTexCoords, numIndices, vertexIndices, numFaces, faceVertexCounts, faceMaterialsPtr, mergeVertices ? 1 : 0, vertexMergeTolerance ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void GetFaceMaterials( global::NativeEngine.CUtlVectorString materials ) { NullCheck(); __N.CMpSttcvrly_GetFaceMaterials( self, materials ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMpSttcvrly_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMpSttcvrly_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMpSttcvrly_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMpSttcvrly_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMpSttcvrly_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMpSttcvrly_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMpSttcvrly_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMpSttcvrly_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMpSttcvrly_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMpSttcvrly_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMpSttcvrly_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMpSttcvrly_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMpSttcvrly_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMpSttcvrly_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMpSttcvrly_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMpSttcvrly_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMpSttcvrly_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMpSttcvrly_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMpSttcvrly_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMpSttcvrly_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMpSttcvrly_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMpSttcvrly_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMpSttcvrly_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMpSttcvrly_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMpSttcvrly_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMpSttcvrly_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMpSttcvrly_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMpSttcvrly_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMpSttcvrly_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMpSttcvrly_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMpSttcvrly_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMpSttcvrly_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMpSttcvrly_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapMesh_To_CMapStaticOverlay;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapMesh_From_CMapStaticOverlay;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapStaticOverlay;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapStaticOverlay;
			internal static delegate* unmanaged< IntPtr, float, float, IntPtr, void > CMpSttcvrly_CreateCenteredQuad;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMpSttcvrly_AssignMaterialToMesh;
			internal static delegate* unmanaged< IntPtr, int, IntPtr, IntPtr, int, IntPtr, int, IntPtr, IntPtr, int, float, void > CMpSttcvrly_ConstructFromData;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMpSttcvrly_GetFaceMaterials;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMpSttcvrly_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMpSttcvrly_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMpSttcvrly_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMpSttcvrly_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMpSttcvrly_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMpSttcvrly_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMpSttcvrly_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMpSttcvrly_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMpSttcvrly_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMpSttcvrly_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMpSttcvrly_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMpSttcvrly_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMpSttcvrly_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMpSttcvrly_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMpSttcvrly_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMpSttcvrly_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMpSttcvrly_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMpSttcvrly_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMpSttcvrly_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMpSttcvrly_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMpSttcvrly_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMpSttcvrly_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMpSttcvrly_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMpSttcvrly_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMpSttcvrly_CoreAttributeChanged;
		}
	}
}

namespace NativeHammer
{
	internal unsafe partial struct CMapView
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapView value ) => value.self;
		static public implicit operator CMapView( IntPtr value ) => new CMapView { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapView c1, CMapView c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapView c1, CMapView c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapView c && c == this;
		
		internal CMapView( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapView {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapView was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetMapDoc() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapView_GetMapDoc( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkHudDirty() { NullCheck(); __N.CMapView_MarkHudDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::NativeHammer.CToolCamera GetCamera() { NullCheck(); return __N.CMapView_GetCamera( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsActive() { NullCheck(); return __N.CMapView_IsActive( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void GetMousePosition( out Vector2 pos ) { NullCheck(); __N.CMapView_GetMousePosition( self, out pos ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EnterFreeDragMode( Vector2 vClientPos, global::Editor.MapDoc.MapNode pObjectToSelect, Vector3 vecInitialHitNormal, bool bAlignToSurface ) { NullCheck(); __N.CMapView_EnterFreeDragMode( self, &vClientPos, pObjectToSelect == null ? IntPtr.Zero : pObjectToSelect.native, &vecInitialHitNormal, bAlignToSurface ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void UpdateFreeDragMode( Vector2 vClientPos, bool bModifyAlignToSurface ) { NullCheck(); __N.CMapView_UpdateFreeDragMode( self, &vClientPos, bModifyAlignToSurface ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void ExitFreeDragMode( bool bRestoreToolState ) { NullCheck(); __N.CMapView_ExitFreeDragMode( self, bRestoreToolState ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void GetDropTarget( ref Vector3 pVecNormalOut, ref Vector3 pVecDropPointOut, Vector2 vecPoint2D ) { NullCheck(); __N.CMapView_GetDropTarget( self, ref pVecNormalOut, ref pVecDropPointOut, &vecPoint2D ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void UpdateManagedGizmoState( bool isHoveredOverSomething, float distanceFromCamera ) { NullCheck(); __N.CMapView_UpdateManagedGizmoState( self, isHoveredOverSomething ? 1 : 0, distanceFromCamera ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly NativeHammer.ManipulationMode_t GetManipulationMode() { NullCheck(); return (NativeHammer.ManipulationMode_t)(__N.CMapView_GetManipulationMode( self )); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly float HitDistanceAtMouse() { NullCheck(); return __N.CMapView_HitDistanceAtMouse( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, int > CMapView_GetMapDoc;
			internal static delegate* unmanaged< IntPtr, void > CMapView_MarkHudDirty;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapView_GetCamera;
			internal static delegate* unmanaged< IntPtr, int > CMapView_IsActive;
			internal static delegate* unmanaged< IntPtr, out Vector2, void > CMapView_GetMousePosition;
			internal static delegate* unmanaged< IntPtr, Vector2*, IntPtr, Vector3*, int, void > CMapView_EnterFreeDragMode;
			internal static delegate* unmanaged< IntPtr, Vector2*, int, void > CMapView_UpdateFreeDragMode;
			internal static delegate* unmanaged< IntPtr, int, void > CMapView_ExitFreeDragMode;
			internal static delegate* unmanaged< IntPtr, ref Vector3, ref Vector3, Vector2*, void > CMapView_GetDropTarget;
			internal static delegate* unmanaged< IntPtr, int, float, void > CMapView_UpdateManagedGizmoState;
			internal static delegate* unmanaged< IntPtr, long > CMapView_GetManipulationMode;
			internal static delegate* unmanaged< IntPtr, float > CMapView_HitDistanceAtMouse;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CMapWorld
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CMapWorld value ) => value.self;
		static public implicit operator CMapWorld( IntPtr value ) => new CMapWorld { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CMapWorld c1, CMapWorld c2 ) => c1.self == c2.self;
		public static bool operator !=( CMapWorld c1, CMapWorld c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CMapWorld c && c == this;
		
		internal CMapWorld( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CMapWorld {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CMapWorld was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator NativeMapDoc.CMapNode( CMapWorld value ) => __N.To_CMapNode_From_CMapWorld( value );
		static public explicit operator CMapWorld( NativeMapDoc.CMapNode value ) => __N.From_CMapNode_To_CMapWorld( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetSerializedScene( string json ) { NullCheck(); var _str_json = new Sandbox.Interop.InteropString( json ); try { __N.CMapWorld_SetSerializedScene( self, _str_json.Pointer ); } finally { _str_json.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetSerializedScene() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapWorld_GetSerializedScene( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode FindNodeByID( int nodeId ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapWorld_FindNodeByID( self, nodeId ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity FindEntityByNodeId( int nodeId ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapWorld_FindEntityByNodeId( self, nodeId ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly NativeHammer.TraceResult Trace( NativeHammer.TraceRequest traceRequest ) { NullCheck(); return __N.CMapWorld_Trace( self, &traceRequest ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNodeID() { NullCheck(); return __N.CMapWorld_GetNodeID( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetName() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapWorld_GetName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropString( name ); try { __N.CMapWorld_SetName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetParent() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapWorld_GetParent( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetParent( global::Editor.MapDoc.MapNode parent ) { NullCheck(); __N.CMapWorld_SetParent( self, parent == null ? IntPtr.Zero : parent.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapWorld GetParentWorld() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( __N.CMapWorld_GetParentWorld( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapDocument GetRootDocument( Editor.MapDoc.MapNodeGetRootDocument nDocumentLoaded ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( __N.CMapWorld_GetRootDocument( self, (long)(nDocumentLoaded) ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetDescription() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapWorld_GetDescription( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string GetTypeString() { NullCheck(); return Sandbox.Interop.GetString( __N.CMapWorld_GetTypeString( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode Copy() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapWorld_Copy( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsVisible() { NullCheck(); return __N.CMapWorld_IsVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVisible( bool bVisible ) { NullCheck(); __N.CMapWorld_SetVisible( self, bVisible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool IsSelected() { NullCheck(); return __N.CMapWorld_IsSelected( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetChildCount() { NullCheck(); return __N.CMapWorld_GetChildCount( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetChild( int i ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapWorld_GetChild( self, i ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetFirstDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapWorld_GetFirstDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetNextDescendent( ref NativeMapDoc.EnumChildrenPos pos ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.CMapWorld_GetNextDescendent( self, ref pos ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapEntity AsMapEntity() { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapEntity>( __N.CMapWorld_AsMapEntity( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CMapWorld_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CMapWorld_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetScales() { NullCheck(); return __N.CMapWorld_GetScales( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CMapWorld_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CMapWorld_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetScales( Vector3 scales ) { NullCheck(); __N.CMapWorld_SetScales( self, &scales ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BeginTransformOperation( Editor.MapDoc.TransformOperationMode nTransformType, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapWorld_BeginTransformOperation( self, (long)(nTransformType), (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Transform( Matrix matrix, Editor.MapDoc.TransformFlags nFlags ) { NullCheck(); __N.CMapWorld_Transform( self, &matrix, (long)(nFlags) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void EndTransformOperation() { NullCheck(); __N.CMapWorld_EndTransformOperation( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void MarkBoundsDirty() { NullCheck(); __N.CMapWorld_MarkBoundsDirty( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void FullBoundsUpdate() { NullCheck(); __N.CMapWorld_FullBoundsUpdate( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetModifiedFlag() { NullCheck(); __N.CMapWorld_SetModifiedFlag( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool GeneratesEntityModelGeometry() { NullCheck(); return __N.CMapWorld_GeneratesEntityModelGeometry( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DescriptionChanged() { NullCheck(); __N.CMapWorld_DescriptionChanged( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CoreAttributeChanged() { NullCheck(); __N.CMapWorld_CoreAttributeChanged( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CMapNode_To_CMapWorld;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CMapNode_From_CMapWorld;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapWorld_SetSerializedScene;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapWorld_GetSerializedScene;
			internal static delegate* unmanaged< IntPtr, int, int > CMapWorld_FindNodeByID;
			internal static delegate* unmanaged< IntPtr, int, int > CMapWorld_FindEntityByNodeId;
			internal static delegate* unmanaged< IntPtr, NativeHammer.TraceRequest*, NativeHammer.TraceResult > CMapWorld_Trace;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_GetNodeID;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapWorld_GetName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapWorld_SetName;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_GetParent;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CMapWorld_SetParent;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_GetParentWorld;
			internal static delegate* unmanaged< IntPtr, long, int > CMapWorld_GetRootDocument;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapWorld_GetDescription;
			internal static delegate* unmanaged< IntPtr, IntPtr > CMapWorld_GetTypeString;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_Copy;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_IsVisible;
			internal static delegate* unmanaged< IntPtr, int, void > CMapWorld_SetVisible;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_IsSelected;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_GetChildCount;
			internal static delegate* unmanaged< IntPtr, int, int > CMapWorld_GetChild;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapWorld_GetFirstDescendent;
			internal static delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int > CMapWorld_GetNextDescendent;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_AsMapEntity;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapWorld_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CMapWorld_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3 > CMapWorld_GetScales;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapWorld_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CMapWorld_SetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CMapWorld_SetScales;
			internal static delegate* unmanaged< IntPtr, long, long, void > CMapWorld_BeginTransformOperation;
			internal static delegate* unmanaged< IntPtr, Matrix*, long, void > CMapWorld_Transform;
			internal static delegate* unmanaged< IntPtr, void > CMapWorld_EndTransformOperation;
			internal static delegate* unmanaged< IntPtr, void > CMapWorld_MarkBoundsDirty;
			internal static delegate* unmanaged< IntPtr, void > CMapWorld_FullBoundsUpdate;
			internal static delegate* unmanaged< IntPtr, void > CMapWorld_SetModifiedFlag;
			internal static delegate* unmanaged< IntPtr, int > CMapWorld_GeneratesEntityModelGeometry;
			internal static delegate* unmanaged< IntPtr, void > CMapWorld_DescriptionChanged;
			internal static delegate* unmanaged< IntPtr, void > CMapWorld_CoreAttributeChanged;
		}
	}
}

namespace Native
{
	internal unsafe partial struct CQHammerMainWnd
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CQHammerMainWnd value ) => value.self;
		static public implicit operator CQHammerMainWnd( IntPtr value ) => new CQHammerMainWnd { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CQHammerMainWnd c1, CQHammerMainWnd c2 ) => c1.self == c2.self;
		public static bool operator !=( CQHammerMainWnd c1, CQHammerMainWnd c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CQHammerMainWnd c && c == this;
		
		internal CQHammerMainWnd( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CQHammerMainWnd {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CQHammerMainWnd was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		// Converting to/from base classes (important if multiple inheritence, because they won't be the same pointer)
		static public implicit operator Native.CFramelessMainWindow( CQHammerMainWnd value ) => __N.To_CFramelessMainWindow_From_CQHammerMainWnd( value );
		static public explicit operator CQHammerMainWnd( Native.CFramelessMainWindow value ) => __N.From_CFramelessMainWindow_To_CQHammerMainWnd( value );
		static public implicit operator Native.QMainWindow( CQHammerMainWnd value ) => __N.To_QMainWindow_From_CQHammerMainWnd( value );
		static public explicit operator CQHammerMainWnd( Native.QMainWindow value ) => __N.From_QMainWindow_To_CQHammerMainWnd( value );
		static public implicit operator Native.QWidget( CQHammerMainWnd value ) => __N.To_QWidget_From_CQHammerMainWnd( value );
		static public explicit operator CQHammerMainWnd( Native.QWidget value ) => __N.From_QWidget_To_CQHammerMainWnd( value );
		static public implicit operator Native.QObject( CQHammerMainWnd value ) => __N.To_QObject_From_CQHammerMainWnd( value );
		static public explicit operator CQHammerMainWnd( Native.QObject value ) => __N.From_QObject_To_CQHammerMainWnd( value );
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CreateEverything() { NullCheck(); __N.CQHammerMainWnd_CreateEverything( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void CreateMenus() { NullCheck(); __N.CQHammerMainWnd_CreateMenus( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetupDefaultLayout() { NullCheck(); __N.CQHammerMainWnd_SetupDefaultLayout( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetTitleBarWidgets( global::Native.QPushButton icon, global::Native.QLabel titleLabel, global::Native.QMenuBar menuBar, global::Native.QWidget grabber, global::Native.QWidget minimizeButton, global::Native.QWidget maximizeButton, global::Native.QWidget closeButton ) { NullCheck(); __N.CQHammerMainWnd_SetTitleBarWidgets( self, icon, titleLabel, menuBar, grabber, minimizeButton, maximizeButton, closeButton ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 iconSize() { NullCheck(); return __N.CQHammerMainWnd_iconSize( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setIconSize( Vector3 iconSize ) { NullCheck(); __N.CQHammerMainWnd_setIconSize( self, iconSize ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Native.QMenuBar menuBar() { NullCheck(); return __N.CQHammerMainWnd_menuBar( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setMenuBar( global::Native.QMenuBar menubar ) { NullCheck(); __N.CQHammerMainWnd_setMenuBar( self, menubar ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setMenuWidget( global::Native.QWidget menubar ) { NullCheck(); __N.CQHammerMainWnd_setMenuWidget( self, menubar ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Native.QStatusBar statusBar() { NullCheck(); return __N.CQHammerMainWnd_statusBar( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setStatusBar( global::Native.QStatusBar statusbar ) { NullCheck(); __N.CQHammerMainWnd_setStatusBar( self, statusbar ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Native.QWidget centralWidget() { NullCheck(); return __N.CQHammerMainWnd_centralWidget( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setCentralWidget( global::Native.QWidget widget ) { NullCheck(); __N.CQHammerMainWnd_setCentralWidget( self, widget ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isAnimated() { NullCheck(); return __N.CQHammerMainWnd_isAnimated( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setAnimated( bool enabled ) { NullCheck(); __N.CQHammerMainWnd_setAnimated( self, enabled ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void addToolBarBreak( Editor.ToolbarPosition area ) { NullCheck(); __N.CQHammerMainWnd_addToolBarBreak( self, (long)(area) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void insertToolBarBreak( global::Native.QToolBar before ) { NullCheck(); __N.CQHammerMainWnd_insertToolBarBreak( self, before ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void addToolBar( Editor.ToolbarPosition area, global::Native.QToolBar toolbar ) { NullCheck(); __N.CQHammerMainWnd_addToolBar( self, (long)(area), toolbar ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void addToolBar( global::Native.QToolBar toolbar ) { NullCheck(); __N.CQHammerMainWnd_addToolBar_1( self, toolbar ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void insertToolBar( global::Native.QToolBar before, global::Native.QToolBar toolbar ) { NullCheck(); __N.CQHammerMainWnd_insertToolBar( self, before, toolbar ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void removeToolBar( global::Native.QToolBar toolbar ) { NullCheck(); __N.CQHammerMainWnd_removeToolBar( self, toolbar ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void removeToolBarBreak( global::Native.QToolBar before ) { NullCheck(); __N.CQHammerMainWnd_removeToolBarBreak( self, before ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string saveState( int version ) { NullCheck(); return Sandbox.Interop.GetString( __N.CQHammerMainWnd_saveState( self, version ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool restoreState( string state ) { NullCheck(); var _str_state = new Sandbox.Interop.InteropString( state ); try { return __N.CQHammerMainWnd_restoreState( self, _str_state.Pointer ) != 0; } finally { _str_state.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isTopLevel() { NullCheck(); return __N.CQHammerMainWnd_isTopLevel( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isWindow() { NullCheck(); return __N.CQHammerMainWnd_isWindow( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isModal() { NullCheck(); return __N.CQHammerMainWnd_isModal( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setStyleSheet( string sheet ) { NullCheck(); var _str_sheet = new Sandbox.Interop.InteropWString( sheet ); try { __N.CQHammerMainWnd_setStyleSheet( self, _str_sheet.Pointer ); } finally { _str_sheet.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string windowTitle() { NullCheck(); return Sandbox.Interop.GetWString( __N.CQHammerMainWnd_windowTitle( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setWindowTitle( string title ) { NullCheck(); var _str_title = new Sandbox.Interop.InteropWString( title ); try { __N.CQHammerMainWnd_setWindowTitle( self, _str_title.Pointer ); } finally { _str_title.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setWindowFlags( Editor.WindowFlags type ) { NullCheck(); __N.CQHammerMainWnd_setWindowFlags( self, (long)(type) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Editor.WindowFlags windowFlags() { NullCheck(); return (Editor.WindowFlags)(__N.CQHammerMainWnd_windowFlags( self )); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 size() { NullCheck(); return __N.CQHammerMainWnd_size( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void resize( Vector3 x ) { NullCheck(); __N.CQHammerMainWnd_resize( self, x ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 minimumSize() { NullCheck(); return __N.CQHammerMainWnd_minimumSize( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setMinimumSize( Vector3 x ) { NullCheck(); __N.CQHammerMainWnd_setMinimumSize( self, x ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 maximumSize() { NullCheck(); return __N.CQHammerMainWnd_maximumSize( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setMaximumSize( Vector3 x ) { NullCheck(); __N.CQHammerMainWnd_setMaximumSize( self, x ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 sizeHint() { NullCheck(); return __N.CQHammerMainWnd_sizeHint( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 pos() { NullCheck(); return __N.CQHammerMainWnd_pos( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void move( Vector3 x ) { NullCheck(); __N.CQHammerMainWnd_move( self, x ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isEnabled() { NullCheck(); return __N.CQHammerMainWnd_isEnabled( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setEnabled( bool x ) { NullCheck(); __N.CQHammerMainWnd_setEnabled( self, x ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setVisible( bool visible ) { NullCheck(); __N.CQHammerMainWnd_setVisible( self, visible ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void show() { NullCheck(); __N.CQHammerMainWnd_show( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void hide() { NullCheck(); __N.CQHammerMainWnd_hide( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void showMinimized() { NullCheck(); __N.CQHammerMainWnd_showMinimized( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void showMaximized() { NullCheck(); __N.CQHammerMainWnd_showMaximized( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void showFullScreen() { NullCheck(); __N.CQHammerMainWnd_showFullScreen( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void showNormal() { NullCheck(); __N.CQHammerMainWnd_showNormal( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool close() { NullCheck(); return __N.CQHammerMainWnd_close( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void raise() { NullCheck(); __N.CQHammerMainWnd_raise( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void lower() { NullCheck(); __N.CQHammerMainWnd_lower( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isVisible() { NullCheck(); return __N.CQHammerMainWnd_isVisible( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isHidden() { NullCheck(); return __N.CQHammerMainWnd_isHidden( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setHidden( bool b ) { NullCheck(); __N.CQHammerMainWnd_setHidden( self, b ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setAttribute( Editor.Widget.Flag a, bool on ) { NullCheck(); __N.CQHammerMainWnd_setAttribute( self, (long)(a), on ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool testAttribute( Editor.Widget.Flag a ) { NullCheck(); return __N.CQHammerMainWnd_testAttribute( self, (long)(a) ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool acceptDrops() { NullCheck(); return __N.CQHammerMainWnd_acceptDrops( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setAcceptDrops( bool on ) { NullCheck(); __N.CQHammerMainWnd_setAcceptDrops( self, on ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void updateGeometry() { NullCheck(); __N.CQHammerMainWnd_updateGeometry( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void update() { NullCheck(); __N.CQHammerMainWnd_update( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void repaint() { NullCheck(); __N.CQHammerMainWnd_repaint( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setCursor( Editor.CursorShape shape ) { NullCheck(); __N.CQHammerMainWnd_setCursor( self, (long)(shape) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setCursor( global::Native.QPixmap pixmap ) { NullCheck(); __N.CQHammerMainWnd_setCursor_1( self, pixmap ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void unsetCursor() { NullCheck(); __N.CQHammerMainWnd_unsetCursor( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setWindowIcon( string icon ) { NullCheck(); var _str_icon = new Sandbox.Interop.InteropString( icon ); try { __N.CQHammerMainWnd_setWindowIcon( self, _str_icon.Pointer ); } finally { _str_icon.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setWindowIconFromPixmap( global::Native.QPixmap icon ) { NullCheck(); __N.CQHammerMainWnd_setWindowIconFromPixmap( self, icon ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setWindowIconText( string str ) { NullCheck(); var _str_str = new Sandbox.Interop.InteropWString( str ); try { __N.CQHammerMainWnd_setWindowIconText( self, _str_str.Pointer ); } finally { _str_str.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setWindowOpacity( float level ) { NullCheck(); __N.CQHammerMainWnd_setWindowOpacity( self, level ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly float windowOpacity() { NullCheck(); return __N.CQHammerMainWnd_windowOpacity( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isMinimized() { NullCheck(); return __N.CQHammerMainWnd_isMinimized( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isMaximized() { NullCheck(); return __N.CQHammerMainWnd_isMaximized( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isFullScreen() { NullCheck(); return __N.CQHammerMainWnd_isFullScreen( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setMouseTracking( bool enable ) { NullCheck(); __N.CQHammerMainWnd_setMouseTracking( self, enable ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool hasMouseTracking() { NullCheck(); return __N.CQHammerMainWnd_hasMouseTracking( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool underMouse() { NullCheck(); return __N.CQHammerMainWnd_underMouse( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 mapToGlobal( Vector3 p ) { NullCheck(); return __N.CQHammerMainWnd_mapToGlobal( self, p ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 mapFromGlobal( Vector3 p ) { NullCheck(); return __N.CQHammerMainWnd_mapFromGlobal( self, p ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool hasFocus() { NullCheck(); return __N.CQHammerMainWnd_hasFocus( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Editor.FocusMode focusPolicy() { NullCheck(); return (Editor.FocusMode)(__N.CQHammerMainWnd_focusPolicy( self )); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setFocusPolicy( Editor.FocusMode policy ) { NullCheck(); __N.CQHammerMainWnd_setFocusPolicy( self, (long)(policy) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setFocusProxy( global::Native.QWidget widget ) { NullCheck(); __N.CQHammerMainWnd_setFocusProxy( self, widget ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool isActiveWindow() { NullCheck(); return __N.CQHammerMainWnd_isActiveWindow( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool updatesEnabled() { NullCheck(); return __N.CQHammerMainWnd_updatesEnabled( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setUpdatesEnabled( bool enable ) { NullCheck(); __N.CQHammerMainWnd_setUpdatesEnabled( self, enable ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setFocus() { NullCheck(); __N.CQHammerMainWnd_setFocus( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void activateWindow() { NullCheck(); __N.CQHammerMainWnd_activateWindow( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void clearFocus() { NullCheck(); __N.CQHammerMainWnd_clearFocus( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly float devicePixelRatioF() { NullCheck(); return __N.CQHammerMainWnd_devicePixelRatioF( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string saveGeometry() { NullCheck(); return Sandbox.Interop.GetString( __N.CQHammerMainWnd_saveGeometry( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool restoreGeometry( string state ) { NullCheck(); var _str_state = new Sandbox.Interop.InteropString( state ); try { return __N.CQHammerMainWnd_restoreGeometry( self, _str_state.Pointer ) != 0; } finally { _str_state.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void addAction( global::Native.QAction action ) { NullCheck(); __N.CQHammerMainWnd_addAction( self, action ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void removeAction( global::Native.QAction action ) { NullCheck(); __N.CQHammerMainWnd_removeAction( self, action ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setParent( global::Native.QWidget parent ) { NullCheck(); __N.CQHammerMainWnd_setParent( self, parent ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Native.QWidget parentWidget() { NullCheck(); return __N.CQHammerMainWnd_parentWidget( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Native.QWidget window() { NullCheck(); return __N.CQHammerMainWnd_window( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void AddClassName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropWString( name ); try { __N.CQHammerMainWnd_AddClassName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void Polish() { NullCheck(); __N.CQHammerMainWnd_Polish( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string toolTip() { NullCheck(); return Sandbox.Interop.GetWString( __N.CQHammerMainWnd_toolTip( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setToolTip( string str ) { NullCheck(); var _str_str = new Sandbox.Interop.InteropWString( str ); try { __N.CQHammerMainWnd_setToolTip( self, _str_str.Pointer ); } finally { _str_str.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string statusTip() { NullCheck(); return Sandbox.Interop.GetWString( __N.CQHammerMainWnd_statusTip( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setStatusTip( string str ) { NullCheck(); var _str_str = new Sandbox.Interop.InteropWString( str ); try { __N.CQHammerMainWnd_setStatusTip( self, _str_str.Pointer ); } finally { _str_str.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int toolTipDuration() { NullCheck(); return __N.CQHammerMainWnd_toolTipDuration( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setToolTipDuration( int x ) { NullCheck(); __N.CQHammerMainWnd_setToolTipDuration( self, x ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool autoFillBackground() { NullCheck(); return __N.CQHammerMainWnd_autoFillBackground( self ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setAutoFillBackground( bool enabled ) { NullCheck(); __N.CQHammerMainWnd_setAutoFillBackground( self, enabled ? 1 : 0 ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void adjustSize() { NullCheck(); __N.CQHammerMainWnd_adjustSize( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Editor.WindowModality windowModality() { NullCheck(); return (Editor.WindowModality)(__N.CQHammerMainWnd_windowModality( self )); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setWindowModality( Editor.WindowModality windowModality ) { NullCheck(); __N.CQHammerMainWnd_setWindowModality( self, (long)(windowModality) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly QRectF ScreenGeometry() { NullCheck(); return __N.CQHammerMainWnd_ScreenGeometry( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setContentsMargins( int left, int top, int right, int bottom ) { NullCheck(); __N.CQHammerMainWnd_setContentsMargins( self, left, top, right, bottom ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly QRectF contentsMargins() { NullCheck(); return __N.CQHammerMainWnd_contentsMargins( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Native.QLayout layout() { NullCheck(); return __N.CQHammerMainWnd_layout( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setLayout( global::Native.QLayout l ) { NullCheck(); __N.CQHammerMainWnd_setLayout( self, l ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly QRectF contentsRect() { NullCheck(); return __N.CQHammerMainWnd_contentsRect( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetEffectOpacity( float opacity ) { NullCheck(); __N.CQHammerMainWnd_SetEffectOpacity( self, opacity ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setSizePolicy( Editor.SizeMode x, Editor.SizeMode y ) { NullCheck(); __N.CQHammerMainWnd_setSizePolicy( self, (long)(x), (long)(y) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Editor.SizeMode GetHorizontalSizePolicy() { NullCheck(); return (Editor.SizeMode)(__N.CQHammerMainWnd_GetHorizontalSizePolicy( self )); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Editor.SizeMode GetVerticalSizePolicy() { NullCheck(); return (Editor.SizeMode)(__N.CQHammerMainWnd_GetVerticalSizePolicy( self )); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetHorizontalSizePolicy( Editor.SizeMode mode ) { NullCheck(); __N.CQHammerMainWnd_SetHorizontalSizePolicy( self, (long)(mode) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetVerticalSizePolicy( Editor.SizeMode mode ) { NullCheck(); __N.CQHammerMainWnd_SetVerticalSizePolicy( self, (long)(mode) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setFixedSize( int w, int h ) { NullCheck(); __N.CQHammerMainWnd_setFixedSize( self, w, h ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setFixedWidth( int w ) { NullCheck(); __N.CQHammerMainWnd_setFixedWidth( self, w ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setFixedHeight( int h ) { NullCheck(); __N.CQHammerMainWnd_setFixedHeight( self, h ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly IntPtr winId() { NullCheck(); return __N.CQHammerMainWnd_winId( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void deleteLater() { NullCheck(); __N.CQHammerMainWnd_deleteLater( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly string objectName() { NullCheck(); return Sandbox.Interop.GetWString( __N.CQHammerMainWnd_objectName( self ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setObjectName( string name ) { NullCheck(); var _str_name = new Sandbox.Interop.InteropWString( name ); try { __N.CQHammerMainWnd_setObjectName( self, _str_name.Pointer ); } finally { _str_name.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setParent( global::Native.QObject parent ) { NullCheck(); __N.CQHammerMainWnd_setParent_1( self, parent ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setProperty( string key, bool value ) { NullCheck(); var _str_key = new Sandbox.Interop.InteropString( key ); try { __N.CQHammerMainWnd_setProperty( self, _str_key.Pointer, value ? 1 : 0 ); } finally { _str_key.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setProperty( string key, float value ) { NullCheck(); var _str_key = new Sandbox.Interop.InteropString( key ); try { __N.CQHammerMainWnd_setProperty_1( self, _str_key.Pointer, value ); } finally { _str_key.Free(); }  }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void setProperty( string key, string value ) { NullCheck(); var _str_value = new Sandbox.Interop.InteropString( value ); try { var _str_key = new Sandbox.Interop.InteropString( key ); try { __N.CQHammerMainWnd_setProperty_2( self, _str_key.Pointer, _str_value.Pointer ); } finally { _str_key.Free(); }  } finally { _str_value.Free(); }  }
		internal static class __N
		{
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_CFramelessMainWindow_To_CQHammerMainWnd;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_CFramelessMainWindow_From_CQHammerMainWnd;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_QMainWindow_To_CQHammerMainWnd;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_QMainWindow_From_CQHammerMainWnd;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_QWidget_To_CQHammerMainWnd;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_QWidget_From_CQHammerMainWnd;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > From_QObject_To_CQHammerMainWnd;
			internal static delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr > To_QObject_From_CQHammerMainWnd;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_CreateEverything;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_CreateMenus;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_SetupDefaultLayout;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, void > CQHammerMainWnd_SetTitleBarWidgets;
			internal static delegate* unmanaged< IntPtr, Vector3 > CQHammerMainWnd_iconSize;
			internal static delegate* unmanaged< IntPtr, Vector3, void > CQHammerMainWnd_setIconSize;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_menuBar;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setMenuBar;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setMenuWidget;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_statusBar;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setStatusBar;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_centralWidget;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setCentralWidget;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isAnimated;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setAnimated;
			internal static delegate* unmanaged< IntPtr, long, void > CQHammerMainWnd_addToolBarBreak;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_insertToolBarBreak;
			internal static delegate* unmanaged< IntPtr, long, IntPtr, void > CQHammerMainWnd_addToolBar;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_addToolBar_1;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, void > CQHammerMainWnd_insertToolBar;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_removeToolBar;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_removeToolBarBreak;
			internal static delegate* unmanaged< IntPtr, int, IntPtr > CQHammerMainWnd_saveState;
			internal static delegate* unmanaged< IntPtr, IntPtr, int > CQHammerMainWnd_restoreState;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isTopLevel;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isWindow;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isModal;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setStyleSheet;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_windowTitle;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setWindowTitle;
			internal static delegate* unmanaged< IntPtr, long, void > CQHammerMainWnd_setWindowFlags;
			internal static delegate* unmanaged< IntPtr, long > CQHammerMainWnd_windowFlags;
			internal static delegate* unmanaged< IntPtr, Vector3 > CQHammerMainWnd_size;
			internal static delegate* unmanaged< IntPtr, Vector3, void > CQHammerMainWnd_resize;
			internal static delegate* unmanaged< IntPtr, Vector3 > CQHammerMainWnd_minimumSize;
			internal static delegate* unmanaged< IntPtr, Vector3, void > CQHammerMainWnd_setMinimumSize;
			internal static delegate* unmanaged< IntPtr, Vector3 > CQHammerMainWnd_maximumSize;
			internal static delegate* unmanaged< IntPtr, Vector3, void > CQHammerMainWnd_setMaximumSize;
			internal static delegate* unmanaged< IntPtr, Vector3 > CQHammerMainWnd_sizeHint;
			internal static delegate* unmanaged< IntPtr, Vector3 > CQHammerMainWnd_pos;
			internal static delegate* unmanaged< IntPtr, Vector3, void > CQHammerMainWnd_move;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isEnabled;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setEnabled;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setVisible;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_show;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_hide;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_showMinimized;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_showMaximized;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_showFullScreen;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_showNormal;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_close;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_raise;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_lower;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isVisible;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isHidden;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setHidden;
			internal static delegate* unmanaged< IntPtr, long, int, void > CQHammerMainWnd_setAttribute;
			internal static delegate* unmanaged< IntPtr, long, int > CQHammerMainWnd_testAttribute;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_acceptDrops;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setAcceptDrops;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_updateGeometry;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_update;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_repaint;
			internal static delegate* unmanaged< IntPtr, long, void > CQHammerMainWnd_setCursor;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setCursor_1;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_unsetCursor;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setWindowIcon;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setWindowIconFromPixmap;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setWindowIconText;
			internal static delegate* unmanaged< IntPtr, float, void > CQHammerMainWnd_setWindowOpacity;
			internal static delegate* unmanaged< IntPtr, float > CQHammerMainWnd_windowOpacity;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isMinimized;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isMaximized;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isFullScreen;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setMouseTracking;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_hasMouseTracking;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_underMouse;
			internal static delegate* unmanaged< IntPtr, Vector3, Vector3 > CQHammerMainWnd_mapToGlobal;
			internal static delegate* unmanaged< IntPtr, Vector3, Vector3 > CQHammerMainWnd_mapFromGlobal;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_hasFocus;
			internal static delegate* unmanaged< IntPtr, long > CQHammerMainWnd_focusPolicy;
			internal static delegate* unmanaged< IntPtr, long, void > CQHammerMainWnd_setFocusPolicy;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setFocusProxy;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_isActiveWindow;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_updatesEnabled;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setUpdatesEnabled;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_setFocus;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_activateWindow;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_clearFocus;
			internal static delegate* unmanaged< IntPtr, float > CQHammerMainWnd_devicePixelRatioF;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_saveGeometry;
			internal static delegate* unmanaged< IntPtr, IntPtr, int > CQHammerMainWnd_restoreGeometry;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_addAction;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_removeAction;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setParent;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_parentWidget;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_window;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_AddClassName;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_Polish;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_toolTip;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setToolTip;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_statusTip;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setStatusTip;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_toolTipDuration;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setToolTipDuration;
			internal static delegate* unmanaged< IntPtr, int > CQHammerMainWnd_autoFillBackground;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setAutoFillBackground;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_adjustSize;
			internal static delegate* unmanaged< IntPtr, long > CQHammerMainWnd_windowModality;
			internal static delegate* unmanaged< IntPtr, long, void > CQHammerMainWnd_setWindowModality;
			internal static delegate* unmanaged< IntPtr, QRectF > CQHammerMainWnd_ScreenGeometry;
			internal static delegate* unmanaged< IntPtr, int, int, int, int, void > CQHammerMainWnd_setContentsMargins;
			internal static delegate* unmanaged< IntPtr, QRectF > CQHammerMainWnd_contentsMargins;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_layout;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setLayout;
			internal static delegate* unmanaged< IntPtr, QRectF > CQHammerMainWnd_contentsRect;
			internal static delegate* unmanaged< IntPtr, float, void > CQHammerMainWnd_SetEffectOpacity;
			internal static delegate* unmanaged< IntPtr, long, long, void > CQHammerMainWnd_setSizePolicy;
			internal static delegate* unmanaged< IntPtr, long > CQHammerMainWnd_GetHorizontalSizePolicy;
			internal static delegate* unmanaged< IntPtr, long > CQHammerMainWnd_GetVerticalSizePolicy;
			internal static delegate* unmanaged< IntPtr, long, void > CQHammerMainWnd_SetHorizontalSizePolicy;
			internal static delegate* unmanaged< IntPtr, long, void > CQHammerMainWnd_SetVerticalSizePolicy;
			internal static delegate* unmanaged< IntPtr, int, int, void > CQHammerMainWnd_setFixedSize;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setFixedWidth;
			internal static delegate* unmanaged< IntPtr, int, void > CQHammerMainWnd_setFixedHeight;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_winId;
			internal static delegate* unmanaged< IntPtr, void > CQHammerMainWnd_deleteLater;
			internal static delegate* unmanaged< IntPtr, IntPtr > CQHammerMainWnd_objectName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setObjectName;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CQHammerMainWnd_setParent_1;
			internal static delegate* unmanaged< IntPtr, IntPtr, int, void > CQHammerMainWnd_setProperty;
			internal static delegate* unmanaged< IntPtr, IntPtr, float, void > CQHammerMainWnd_setProperty_1;
			internal static delegate* unmanaged< IntPtr, IntPtr, IntPtr, void > CQHammerMainWnd_setProperty_2;
		}
	}
}

namespace NativeHammer
{
	internal unsafe partial struct CSavedObjects
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CSavedObjects value ) => value.self;
		static public implicit operator CSavedObjects( IntPtr value ) => new CSavedObjects { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CSavedObjects c1, CSavedObjects c2 ) => c1.self == c2.self;
		public static bool operator !=( CSavedObjects c1, CSavedObjects c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CSavedObjects c && c == this;
		
		internal CSavedObjects( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CSavedObjects {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CSavedObjects was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void DeleteThis() { NullCheck(); __N.CSavedObjects_DeleteThis( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal static global::NativeHammer.CSavedObjects Create() { if ( __N.CSavedObjects_Create == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.CSavedObjects_Create(); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void RemoveAll() { NullCheck(); __N.CSavedObjects_RemoveAll( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SaveObject( global::Editor.MapDoc.MapNode pObject ) { NullCheck(); __N.CSavedObjects_SaveObject( self, pObject == null ? IntPtr.Zero : pObject.native ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void RestoreObjects() { NullCheck(); __N.CSavedObjects_RestoreObjects( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int Count() { NullCheck(); return __N.CSavedObjects_Count( self ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, void > CSavedObjects_DeleteThis;
			internal static delegate* unmanaged< IntPtr > CSavedObjects_Create;
			internal static delegate* unmanaged< IntPtr, void > CSavedObjects_RemoveAll;
			internal static delegate* unmanaged< IntPtr, IntPtr, void > CSavedObjects_SaveObject;
			internal static delegate* unmanaged< IntPtr, void > CSavedObjects_RestoreObjects;
			internal static delegate* unmanaged< IntPtr, int > CSavedObjects_Count;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct CSelection
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CSelection value ) => value.self;
		static public implicit operator CSelection( IntPtr value ) => new CSelection { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CSelection c1, CSelection c2 ) => c1.self == c2.self;
		public static bool operator !=( CSelection c1, CSelection c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CSelection c && c == this;
		
		internal CSelection( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CSelection {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CSelection was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Editor.MapEditor.SelectMode GetMode() { NullCheck(); return (Editor.MapEditor.SelectMode)(__N.CSelection_GetMode( self )); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetMode( Editor.MapEditor.SelectMode mode, NativeMapDoc.SelectionConversionMethod_t method ) { NullCheck(); __N.CSelection_SetMode( self, (long)(mode), (long)(method) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::NativeMapDoc.ISelectionSet ActiveSelectionSet() { NullCheck(); return __N.CSelection_ActiveSelectionSet( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::NativeMapDoc.ISelectionSet GetSelectionSetForMode( Editor.MapEditor.SelectMode nMode ) { NullCheck(); return __N.CSelection_GetSelectionSetForMode( self, (long)(nMode) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int GetNumSelectionSets() { NullCheck(); return __N.CSelection_GetNumSelectionSets( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::NativeMapDoc.ISelectionSet GetSelectionSet( int nIndex ) { NullCheck(); return __N.CSelection_GetSelectionSet( self, nIndex ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, long > CSelection_GetMode;
			internal static delegate* unmanaged< IntPtr, long, long, void > CSelection_SetMode;
			internal static delegate* unmanaged< IntPtr, IntPtr > CSelection_ActiveSelectionSet;
			internal static delegate* unmanaged< IntPtr, long, IntPtr > CSelection_GetSelectionSetForMode;
			internal static delegate* unmanaged< IntPtr, int > CSelection_GetNumSelectionSets;
			internal static delegate* unmanaged< IntPtr, int, IntPtr > CSelection_GetSelectionSet;
		}
	}
}

internal unsafe partial struct CToolBlock
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( CToolBlock value ) => value.self;
	static public implicit operator CToolBlock( IntPtr value ) => new CToolBlock { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( CToolBlock c1, CToolBlock c2 ) => c1.self == c2.self;
	public static bool operator !=( CToolBlock c1, CToolBlock c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is CToolBlock c && c == this;
	
	internal CToolBlock( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"CToolBlock {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CToolBlock was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void OnObjectTypeChanged() { NullCheck(); __N.CToolBlock_OnObjectTypeChanged( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void SetPrimitiveType2D( bool primitiveIs2D ) { NullCheck(); __N.CToolBlock_SetPrimitiveType2D( self, primitiveIs2D ? 1 : 0 ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly bool GetOrientPrimitives() { NullCheck(); return __N.CToolBlock_GetOrientPrimitives( self ) != 0; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void SetOrientPrimitives( bool bOrientPrimitives ) { NullCheck(); __N.CToolBlock_SetOrientPrimitives( self, bOrientPrimitives ? 1 : 0 ); }
	internal string m_OverrideMaterial
	{
		get { NullCheck(); return Sandbox.Interop.GetString( __N.Get__CToolBlock_m_OverrideMaterial( self ) ); }
		set { NullCheck(); var _str_value = new Sandbox.Interop.InteropString( value ); try { __N.Set__CToolBlock_m_OverrideMaterial( self, Sandbox.Interop.GetTemporaryStringPointerForNative( value ) ); } finally { _str_value.Free(); }  }
	}
	
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, void > CToolBlock_OnObjectTypeChanged;
		internal static delegate* unmanaged< IntPtr, int, void > CToolBlock_SetPrimitiveType2D;
		internal static delegate* unmanaged< IntPtr, int > CToolBlock_GetOrientPrimitives;
		internal static delegate* unmanaged< IntPtr, int, void > CToolBlock_SetOrientPrimitives;
		internal static delegate* unmanaged[SuppressGCTransition]<IntPtr, IntPtr> Get__CToolBlock_m_OverrideMaterial;

		internal static delegate* unmanaged[SuppressGCTransition]<IntPtr, IntPtr, void> Set__CToolBlock_m_OverrideMaterial;

	}
}

internal unsafe partial struct CToolBlockState
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( CToolBlockState value ) => value.self;
	static public implicit operator CToolBlockState( IntPtr value ) => new CToolBlockState { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( CToolBlockState c1, CToolBlockState c2 ) => c1.self == c2.self;
	public static bool operator !=( CToolBlockState c1, CToolBlockState c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is CToolBlockState c && c == this;
	
	internal CToolBlockState( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"CToolBlockState {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CToolBlockState was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly BBox GetAABBBounds() { NullCheck(); return __N.CToolBlockState_GetAABBBounds( self ); }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly global::CWorkPlane GetDragWorkPlane() { NullCheck(); return __N.CToolBlockState_GetDragWorkPlane( self ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, BBox > CToolBlockState_GetAABBBounds;
		internal static delegate* unmanaged< IntPtr, IntPtr > CToolBlockState_GetDragWorkPlane;
	}
}

namespace NativeHammer
{
	internal unsafe partial struct CToolCamera
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( CToolCamera value ) => value.self;
		static public implicit operator CToolCamera( IntPtr value ) => new CToolCamera { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( CToolCamera c1, CToolCamera c2 ) => c1.self == c2.self;
		public static bool operator !=( CToolCamera c1, CToolCamera c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is CToolCamera c && c == this;
		
		internal CToolCamera( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"CToolCamera {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CToolCamera was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetOrigin() { NullCheck(); return __N.CToolCamera_GetOrigin( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Angles GetAngles() { NullCheck(); return __N.CToolCamera_GetAngles( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetOrigin( Vector3 origin ) { NullCheck(); __N.CToolCamera_SetOrigin( self, &origin ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetAngles( Angles angles ) { NullCheck(); __N.CToolCamera_SetAngles( self, &angles ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly float GetWidth() { NullCheck(); return __N.CToolCamera_GetWidth( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly float GetHeight() { NullCheck(); return __N.CToolCamera_GetHeight( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly float GetCameraFOV() { NullCheck(); return __N.CToolCamera_GetCameraFOV( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void BuildRay( Vector2 view, out Vector3 start, out Vector3 end ) { NullCheck(); __N.CToolCamera_BuildRay( self, &view, out start, out end ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, Vector3 > CToolCamera_GetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles > CToolCamera_GetAngles;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > CToolCamera_SetOrigin;
			internal static delegate* unmanaged< IntPtr, Angles*, void > CToolCamera_SetAngles;
			internal static delegate* unmanaged< IntPtr, float > CToolCamera_GetWidth;
			internal static delegate* unmanaged< IntPtr, float > CToolCamera_GetHeight;
			internal static delegate* unmanaged< IntPtr, float > CToolCamera_GetCameraFOV;
			internal static delegate* unmanaged< IntPtr, Vector2*, out Vector3, out Vector3, void > CToolCamera_BuildRay;
		}
	}
}

internal unsafe partial struct CToolEntity
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( CToolEntity value ) => value.self;
	static public implicit operator CToolEntity( IntPtr value ) => new CToolEntity { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( CToolEntity c1, CToolEntity c2 ) => c1.self == c2.self;
	public static bool operator !=( CToolEntity c1, CToolEntity c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is CToolEntity c && c == this;
	
	internal CToolEntity( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"CToolEntity {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CToolEntity was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void StartBlockEntityCreation( string className ) { NullCheck(); var _str_className = new Sandbox.Interop.InteropString( className ); try { __N.CToolEntity_StartBlockEntityCreation( self, _str_className.Pointer ); } finally { _str_className.Free(); }  }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, IntPtr, void > CToolEntity_StartBlockEntityCreation;
	}
}

internal unsafe partial struct CWorkPlane
{
	internal IntPtr self;
	
	// Allow blindly converting from an IntPtr
	static public implicit operator IntPtr( CWorkPlane value ) => value.self;
	static public implicit operator CWorkPlane( IntPtr value ) => new CWorkPlane { self = value };
	
	// Allow us to compare these pointers
	public static bool operator ==( CWorkPlane c1, CWorkPlane c2 ) => c1.self == c2.self;
	public static bool operator !=( CWorkPlane c1, CWorkPlane c2 ) => c1.self != c2.self;
	public readonly override bool Equals( object obj ) => obj is CWorkPlane c && c == this;
	
	internal CWorkPlane( IntPtr ptr ) { self = ptr; }
	public override string ToString() => $"CWorkPlane {self:x}";
	// Helpers to check validity
	
	internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
	internal readonly bool IsValid => !IsNull;
	internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"CWorkPlane was null when calling {n}" ); }
	public readonly override int GetHashCode() => self.GetHashCode();
	
	[MethodImpl( MethodImplOptions.AggressiveInlining )]
	internal readonly Matrix GetWorkPlaneToWorldTransform() { NullCheck(); return __N.CWorkPlane_GetWorkPlaneToWorldTransform( self ); }
	internal static class __N
	{
		internal static delegate* unmanaged< IntPtr, Matrix > CWorkPlane_GetWorkPlaneToWorldTransform;
	}
}

namespace NativeHammer
{
	internal unsafe static partial class Global
	{
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal static int MaterialGetMappingWidth( global::NativeEngine.IMaterial material ) { if ( __N.global_MaterialGetMappingWidth == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.global_MaterialGetMappingWidth( material ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal static int MaterialGetMappingHeight( global::NativeEngine.IMaterial material ) { if ( __N.global_MaterialGetMappingHeight == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.global_MaterialGetMappingHeight( material ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, int > global_MaterialGetMappingWidth;
			internal static delegate* unmanaged< IntPtr, int > global_MaterialGetMappingHeight;
		}
	}
}

namespace NativeMapDoc
{
	internal unsafe partial struct ISelectionSet
	{
		internal IntPtr self;
		
		// Allow blindly converting from an IntPtr
		static public implicit operator IntPtr( ISelectionSet value ) => value.self;
		static public implicit operator ISelectionSet( IntPtr value ) => new ISelectionSet { self = value };
		
		// Allow us to compare these pointers
		public static bool operator ==( ISelectionSet c1, ISelectionSet c2 ) => c1.self == c2.self;
		public static bool operator !=( ISelectionSet c1, ISelectionSet c2 ) => c1.self != c2.self;
		public readonly override bool Equals( object obj ) => obj is ISelectionSet c && c == this;
		
		internal ISelectionSet( IntPtr ptr ) { self = ptr; }
		public override string ToString() => $"ISelectionSet {self:x}";
		// Helpers to check validity
		
		internal readonly bool IsNull{ [MethodImpl( MethodImplOptions.AggressiveInlining )] get { return self == IntPtr.Zero; } }
		internal readonly bool IsValid => !IsNull;
		internal readonly IntPtr GetPointerAssertIfNull(){ NullCheck(); return self; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void NullCheck( [CallerMemberName] string n = "" ) { if ( IsNull ) throw new System.NullReferenceException( $"ISelectionSet was null when calling {n}" ); }
		public readonly override int GetHashCode() => self.GetHashCode();
		
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly bool SelectObject( global::Editor.MapDoc.MapNode pObject, NativeMapDoc.SelectionOperation_t selectOp ) { NullCheck(); return __N.ISelectionSet_SelectObject( self, pObject == null ? IntPtr.Zero : pObject.native, (long)(selectOp) ) != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly global::Editor.MapDoc.MapNode GetSelectedObject( int nIndex ) { NullCheck(); return Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( __N.ISelectionSet_GetSelectedObject( self, nIndex ) ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly int Count() { NullCheck(); return __N.ISelectionSet_Count( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void RemoveAll() { NullCheck(); __N.ISelectionSet_RemoveAll( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SelectAll() { NullCheck(); __N.ISelectionSet_SelectAll( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void InvertSelection() { NullCheck(); __N.ISelectionSet_InvertSelection( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly Vector3 GetPivotPosition() { NullCheck(); return __N.ISelectionSet_GetPivotPosition( self ); }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal readonly void SetPivot( Vector3 pivot ) { NullCheck(); __N.ISelectionSet_SetPivot( self, &pivot ); }
		internal static class __N
		{
			internal static delegate* unmanaged< IntPtr, IntPtr, long, int > ISelectionSet_SelectObject;
			internal static delegate* unmanaged< IntPtr, int, int > ISelectionSet_GetSelectedObject;
			internal static delegate* unmanaged< IntPtr, int > ISelectionSet_Count;
			internal static delegate* unmanaged< IntPtr, void > ISelectionSet_RemoveAll;
			internal static delegate* unmanaged< IntPtr, void > ISelectionSet_SelectAll;
			internal static delegate* unmanaged< IntPtr, void > ISelectionSet_InvertSelection;
			internal static delegate* unmanaged< IntPtr, Vector3 > ISelectionSet_GetPivotPosition;
			internal static delegate* unmanaged< IntPtr, Vector3*, void > ISelectionSet_SetPivot;
		}
	}
}

namespace NativeHammer
{
	internal unsafe static partial class Options
	{
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal static bool GetShowHelpers() { if ( __N.NativeHammer_Options_GetShowHelpers == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.NativeHammer_Options_GetShowHelpers() != 0; }
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		internal static bool GetShowGameObjectsOnly() { if ( __N.NativeHammer_Options_GetShowGameObjectsOnly == null ) throw new System.Exception( "Function Pointer Is Null" );return __N.NativeHammer_Options_GetShowGameObjectsOnly() != 0; }
		internal static class __N
		{
			internal static delegate* unmanaged< int > NativeHammer_Options_GetShowHelpers;
			internal static delegate* unmanaged< int > NativeHammer_Options_GetShowGameObjectsOnly;
		}
	}
}

namespace Managed.SourceHammer
{
	internal static unsafe class Exports
	{
		/// <summary>
		/// Editor.MapEditor.BlockToolGlue.BuildGeometry( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_BlockToolGlue_BuildGeometry( int mesh, IntPtr blockState )
		{
			try
			{
				Editor.MapEditor.BlockToolGlue.BuildGeometry( Sandbox.HandleIndex.Get<Editor.MapDoc.MapMesh>( mesh ), blockState );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.BlockToolGlue", "BuildGeometry", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.BlockToolGlue.BuildUI( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static IntPtr dtrMpdtr_BlockToolGlue_BuildUI( IntPtr tool )
		{
			try
			{
				return Editor.MapEditor.BlockToolGlue.BuildUI( tool );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.BlockToolGlue", "BuildUI", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.BlockToolGlue.SetInProgress( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_BlockToolGlue_SetInProgress( int inProgress )
		{
			try
			{
				Editor.MapEditor.BlockToolGlue.SetInProgress( inProgress != 0 );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.BlockToolGlue", "SetInProgress", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.BlockToolGlue.SetOverrideEntity( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_BlockToolGlue_SetOverrideEntity( IntPtr entityName )
		{
			try
			{
				Editor.MapEditor.BlockToolGlue.SetOverrideEntity( Sandbox.Interop.GetString( entityName ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.BlockToolGlue", "SetOverrideEntity", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.EntityToolGlue.Create( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static uint dtrMpdtr_EntityToolGlue_Create( IntPtr tool )
		{
			try
			{
				return  Sandbox.InteropSystem.GetAddress( Editor.MapEditor.EntityToolGlue.Create( tool ), true );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.EntityToolGlue", "Create", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.Init( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_Init( IntPtr app )
		{
			try
			{
				Editor.MapEditor.Hammer.Init( app );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "Init", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.RunFrame( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_RunFrame()
		{
			try
			{
				Editor.MapEditor.Hammer.RunFrame();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "RunFrame", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.Shutdown( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_Shutdown()
		{
			try
			{
				Editor.MapEditor.Hammer.Shutdown();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "Shutdown", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.UpdateActiveMaterial( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_UpdateActiveMaterial( IntPtr material )
		{
			try
			{
				Editor.MapEditor.Hammer.UpdateActiveMaterial( material );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "UpdateActiveMaterial", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.RenderMapViewHUD( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_RenderMapViewHUD( int mapView, IntPtr renderContext )
		{
			try
			{
				Editor.MapEditor.Hammer.RenderMapViewHUD( Sandbox.HandleIndex.Get<Editor.MapEditor.MapView>( mapView ), renderContext );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "RenderMapViewHUD", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.PreSaveMap( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_PreSaveMap( int mapDoc )
		{
			try
			{
				Editor.MapEditor.Hammer.PreSaveMap( Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( mapDoc ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "PreSaveMap", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.PostLoadMap( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_PostLoadMap( int mapDoc )
		{
			try
			{
				Editor.MapEditor.Hammer.PostLoadMap( Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( mapDoc ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "PostLoadMap", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.MapAssetSaved( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_MapAssetSaved( int asset, int mapDoc )
		{
			try
			{
				Editor.MapEditor.Hammer.MapAssetSaved( asset, Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( mapDoc ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "MapAssetSaved", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.OnMapViewOpenContextMenu( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_OnMapViewOpenContextMenu( int view, IntPtr menu )
		{
			try
			{
				Editor.MapEditor.Hammer.OnMapViewOpenContextMenu( Sandbox.HandleIndex.Get<Editor.MapEditor.MapView>( view ), menu );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "OnMapViewOpenContextMenu", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Hammer.OnCreateGameObjectMenu( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Hammer_OnCreateGameObjectMenu()
		{
			try
			{
				Editor.MapEditor.Hammer.OnCreateGameObjectMenu();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Hammer", "OnCreateGameObjectMenu", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerEvents.OnMapNodeDescriptionChanged( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerEvents_OnMapNodeDescriptionChanged( int mapNode )
		{
			try
			{
				Editor.MapEditor.HammerEvents.OnMapNodeDescriptionChanged( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( mapNode ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerEvents", "OnMapNodeDescriptionChanged", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerEvents.OnObjectAddedToDocument( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerEvents_OnObjectAddedToDocument( int mapNode, int mapWorld )
		{
			try
			{
				Editor.MapEditor.HammerEvents.OnObjectAddedToDocument( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( mapNode ), Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( mapWorld ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerEvents", "OnObjectAddedToDocument", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerEvents.OnObjectRemovedFromDocument( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerEvents_OnObjectRemovedFromDocument( int mapNode, int mapWorld )
		{
			try
			{
				Editor.MapEditor.HammerEvents.OnObjectRemovedFromDocument( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( mapNode ), Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( mapWorld ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerEvents", "OnObjectRemovedFromDocument", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerEvents.OnMeshesTiedToGameObject( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerEvents_OnMeshesTiedToGameObject( int mapGameObject )
		{
			try
			{
				Editor.MapEditor.HammerEvents.OnMeshesTiedToGameObject( Sandbox.HandleIndex.Get<Editor.MapDoc.MapGameObject>( mapGameObject ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerEvents", "OnMeshesTiedToGameObject", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerMainWindow.WindowInit( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerMainWindow_WindowInit( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerMainWindow>( self, out var instance ) )
					return;
				
				instance.WindowInit();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerMainWindow", "WindowInit", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerMainWindow.AddNativeDock( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerMainWindow_AddNativeDock( uint self, IntPtr name, IntPtr icon, IntPtr sibling, IntPtr window, long dockArea, long properties, float split )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerMainWindow>( self, out var instance ) )
					return;
				
				instance.AddNativeDock( Sandbox.Interop.GetString( name ), Sandbox.Interop.GetString( icon ), sibling, window, (Editor.DockArea)(dockArea), (Editor.DockManager.DockProperty)(properties), split );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerMainWindow", "AddNativeDock", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerMainWindow.CreateDynamicViewMenu( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerMainWindow_CreateDynamicViewMenu( uint self, IntPtr menu )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerMainWindow>( self, out var instance ) )
					return;
				
				instance.CreateDynamicViewMenu( menu );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerMainWindow", "CreateDynamicViewMenu", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerMainWindow.ToggleAssetBrowser( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerMainWindow_ToggleAssetBrowser( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerMainWindow>( self, out var instance ) )
					return;
				
				instance.ToggleAssetBrowser();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerMainWindow", "ToggleAssetBrowser", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerMainWindow.ToggleFullscreenLayout( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerMainWindow_ToggleFullscreenLayout( uint self, int fullscreen )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerMainWindow>( self, out var instance ) )
					return;
				
				instance.ToggleFullscreenLayout( fullscreen != 0 );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerMainWindow", "ToggleFullscreenLayout", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerMainWindow.InitHammerMainWindow( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static uint dtrMpdtr_HammerMainWindow_InitHammerMainWindow( IntPtr window )
		{
			try
			{
				return Editor.MapEditor.HammerMainWindow.InitHammerMainWindow( window );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerMainWindow", "InitHammerMainWindow", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerManagedInspector.Create( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static uint dtrMpdtr_HmmrMngdnspctr_Create( IntPtr parent )
		{
			try
			{
				return  Sandbox.InteropSystem.GetAddress( Editor.MapEditor.HammerManagedInspector.Create( parent ), true );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerManagedInspector", "Create", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerManagedInspector.Inspect( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int dtrMpdtr_HmmrMngdnspctr_Inspect( uint self, int mapnode )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerManagedInspector>( self, out var instance ) )
					return default;
				
				return instance.Inspect( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( mapnode ) ) ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerManagedInspector", "Inspect", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerManagedInspector.GetWidget( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static IntPtr dtrMpdtr_HmmrMngdnspctr_GetWidget( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerManagedInspector>( self, out var instance ) )
					return default;
				
				return instance.GetWidget();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerManagedInspector", "GetWidget", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerSession.Create( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static uint dtrMpdtr_HammerSession_Create( IntPtr native, IntPtr hammer )
		{
			try
			{
				return  Sandbox.InteropSystem.GetAddress( Editor.MapEditor.HammerSession.Create( native, hammer ), true );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerSession", "Create", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerSession.Destroyed( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerSession_Destroyed( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerSession>( self, out var instance ) )
					return;
				
				instance.Destroyed();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerSession", "Destroyed", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerSession.LaunchMapInEngine( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerSession_LaunchMapInEngine( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerSession>( self, out var instance ) )
					return;
				
				instance.LaunchMapInEngine();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerSession", "LaunchMapInEngine", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerSession.OnPreCompileFinished( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerSession_OnPreCompileFinished( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerSession>( self, out var instance ) )
					return;
				
				instance.OnPreCompileFinished();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerSession", "OnPreCompileFinished", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerSession.OnPostCompileFinished( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_HammerSession_OnPostCompileFinished( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerSession>( self, out var instance ) )
					return;
				
				instance.OnPostCompileFinished();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerSession", "OnPostCompileFinished", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.HammerSession.OnPaste( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int dtrMpdtr_HammerSession_OnPaste( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.HammerSession>( self, out var instance ) )
					return default;
				
				return instance.OnPaste() ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.HammerSession", "OnPaste", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.IEntityTool.CreateUI( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_IEntityTool_CreateUI( uint self, IntPtr container )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.IEntityTool>( self, out var instance ) )
					return;
				
				instance.CreateUI( container );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.IEntityTool", "CreateUI", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.IEntityTool.GetCurrentEntityClassName( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static IntPtr dtrMpdtr_IEntityTool_GetCurrentEntityClassName( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.IEntityTool>( self, out var instance ) )
					return default;
				
				return Sandbox.Interop.GetTemporaryStringPointerForNative( instance.GetCurrentEntityClassName() );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.IEntityTool", "GetCurrentEntityClassName", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.IPathTool.CreateUI( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_IPathTool_CreateUI( uint self, IntPtr container )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.IPathTool>( self, out var instance ) )
					return;
				
				instance.CreateUI( container );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.IPathTool", "CreateUI", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.IPathTool.GetCurrentEntityClassName( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static IntPtr dtrMpdtr_IPathTool_GetCurrentEntityClassName( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.IPathTool>( self, out var instance ) )
					return default;
				
				return Sandbox.Interop.GetTemporaryStringPointerForNative( instance.GetCurrentEntityClassName() );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.IPathTool", "GetCurrentEntityClassName", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.IPathTool.GetRadiusOffset( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static float dtrMpdtr_IPathTool_GetRadiusOffset( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.IPathTool>( self, out var instance ) )
					return default;
				
				return instance.GetRadiusOffset();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.IPathTool", "GetRadiusOffset", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.IPathTool.IsRadiusOffsetEnabled( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int dtrMpdtr_IPathTool_IsRadiusOffsetEnabled( uint self )
		{
			try
			{
				if ( !Sandbox.InteropSystem.TryGetObject<Editor.MapEditor.IPathTool>( self, out var instance ) )
					return default;
				
				return instance.IsRadiusOffsetEnabled() ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.IPathTool", "IsRadiusOffsetEnabled", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.OnAddToWorld( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_OnAddToWorld( int node, int world )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.OnAddToWorld( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( node ), Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( world ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "OnAddToWorld", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.OnRemoveFromWorld( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_OnRemoveFromWorld( int node, int world )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.OnRemoveFromWorld( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( node ), Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( world ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "OnRemoveFromWorld", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.PreSaveToFile( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_PreSaveToFile( int node )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.PreSaveToFile( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( node ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "PreSaveToFile", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.PostLoadFromFile( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_PostLoadFromFile( int node )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.PostLoadFromFile( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( node ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "PostLoadFromFile", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.PostLoadDocument( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_PostLoadDocument( int doc )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.PostLoadDocument( Sandbox.HandleIndex.Get<Editor.MapDoc.MapDocument>( doc ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "PostLoadDocument", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.OnCopyFrom( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_OnCopyFrom( int toNode, int fromNode, int copyFlags )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.OnCopyFrom( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( toNode ), Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( fromNode ), copyFlags );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "OnCopyFrom", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.OnParentChanged( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_OnParentChanged( int node, int parent )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.OnParentChanged( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( node ), Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( parent ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "OnParentChanged", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.OnTransformChanged( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_OnTransformChanged( int node, Vector3 position, Angles angle, Vector3 scale )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.OnTransformChanged( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( node ), position, angle, scale );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "OnTransformChanged", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.OnSetEnabled( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_OnSetEnabled( int node, int enabled )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.OnSetEnabled( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( node ), enabled != 0 );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "OnSetEnabled", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.GetMimeData( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_GetMimeData( int node, IntPtr data )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.GetMimeData( Sandbox.HandleIndex.Get<Editor.MapDoc.MapNode>( node ), data );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "GetMimeData", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.GetGameObjectName( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static IntPtr dtrMpdtr_MapNodeCallbacks_GetGameObjectName( int node )
		{
			try
			{
				return Sandbox.Interop.GetTemporaryStringPointerForNative( Editor.MapEditor.MapNodeCallbacks.GetGameObjectName( Sandbox.HandleIndex.Get<Editor.MapDoc.MapGameObject>( node ) ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "GetGameObjectName", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapNodeCallbacks.GetWorldResourceReferencesAndDependencies( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapNodeCallbacks_GetWorldResourceReferencesAndDependencies( int world, IntPtr references )
		{
			try
			{
				Editor.MapEditor.MapNodeCallbacks.GetWorldResourceReferencesAndDependencies( Sandbox.HandleIndex.Get<Editor.MapDoc.MapWorld>( world ), references );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapNodeCallbacks", "GetWorldResourceReferencesAndDependencies", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapViewDropTarget.OnDragEnter( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int dtrMpdtr_MpVwDrpTrgt_OnDragEnter( IntPtr e, int mapView )
		{
			try
			{
				return Editor.MapEditor.MapViewDropTarget.OnDragEnter( e, Sandbox.HandleIndex.Get<Editor.MapEditor.MapView>( mapView ) ) ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapViewDropTarget", "OnDragEnter", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapViewDropTarget.OnDragMove( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int dtrMpdtr_MpVwDrpTrgt_OnDragMove( IntPtr e, int mapView )
		{
			try
			{
				return Editor.MapEditor.MapViewDropTarget.OnDragMove( e, Sandbox.HandleIndex.Get<Editor.MapEditor.MapView>( mapView ) ) ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapViewDropTarget", "OnDragMove", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapViewDropTarget.OnDrop( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int dtrMpdtr_MpVwDrpTrgt_OnDrop( IntPtr e, int mapView )
		{
			try
			{
				return Editor.MapEditor.MapViewDropTarget.OnDrop( e, Sandbox.HandleIndex.Get<Editor.MapEditor.MapView>( mapView ) ) ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapViewDropTarget", "OnDrop", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapViewDropTarget.OnDragLeave( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MpVwDrpTrgt_OnDragLeave( int mapView )
		{
			try
			{
				Editor.MapEditor.MapViewDropTarget.OnDragLeave( Sandbox.HandleIndex.Get<Editor.MapEditor.MapView>( mapView ) );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapViewDropTarget", "OnDragLeave", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapViewDropTarget.GetDragAndDropActive( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int dtrMpdtr_MpVwDrpTrgt_GetDragAndDropActive()
		{
			try
			{
				return Editor.MapEditor.MapViewDropTarget.GetDragAndDropActive() ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapViewDropTarget", "GetDragAndDropActive", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapViewRender.OnPreRender( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_MapViewRender_OnPreRender( int mapView, IntPtr sceneView )
		{
			try
			{
				Editor.MapEditor.MapViewRender.OnPreRender( Sandbox.HandleIndex.Get<Editor.MapEditor.MapView>( mapView ), sceneView );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapViewRender", "OnPreRender", ___e );
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.MapViewRender.TraceManagedGizmos( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static int dtrMpdtr_MapViewRender_TraceManagedGizmos( int mapView, Vector2 vecPoint2D, IntPtr hitInfo )
		{
			try
			{
				return Editor.MapEditor.MapViewRender.TraceManagedGizmos( Sandbox.HandleIndex.Get<Editor.MapEditor.MapView>( mapView ), vecPoint2D, ref Unsafe.AsRef<NativeHammer.HitInfo_t>( (void*) hitInfo ) ) ? 1 : 0;
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.MapViewRender", "TraceManagedGizmos", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.PathToolGlue.Create( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static uint dtrMpdtr_PathToolGlue_Create()
		{
			try
			{
				return  Sandbox.InteropSystem.GetAddress( Editor.MapEditor.PathToolGlue.Create(), true );
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.PathToolGlue", "Create", ___e );
				return default;
			}
		}
		
		/// <summary>
		/// Editor.MapEditor.Selection.OnSelectionChanged( ... )
		/// </summary>
		[UnmanagedCallersOnly]
		internal static void dtrMpdtr_Selection_OnSelectionChanged()
		{
			try
			{
				Editor.MapEditor.Selection.OnSelectionChanged();
			}
			catch ( System.Exception ___e )
			{
				Sandbox.Interop.BindingException( "Editor.MapEditor.Selection", "OnSelectionChanged", ___e );
			}
		}
		
	}
	
	internal unsafe static partial class NativeInterop
	{
		static IntPtr _nativeLibraryHandle;
		static bool _initialized;
		
		[UnmanagedFunctionPointer( CallingConvention.Cdecl )]
		internal delegate void _ErrorFunction( string message );
		
		[UnmanagedFunctionPointer( CallingConvention.Cdecl )]
		delegate void NetCoreImportDelegate( int hash, void* imports, void* exports, int* structSizes );
		
		internal static void Initialize()
		{
			if ( _initialized ) return;
			
			if ( !NativeLibrary.TryLoad( System.IO.Path.Combine( NetCore.NativeDllPath, "tools/libhammer.so" ), out var nativeDll ) )
				Sandbox.Interop.NativeAssemblyLoadFailed( "tools/libhammer.so" );
			_nativeLibraryHandle = nativeDll;
			NetCoreImportDelegate nativeInit = default;
			
			IntPtr nativeInitPtr = NativeLibrary.GetExport( nativeDll, "igen_hammer" );
			if ( nativeInitPtr == IntPtr.Zero )
			
			{
				throw new System.Exception( "Couldn't load from tools/libhammer.so - igen_hammer not found." );
			}
			
			nativeInit = Marshal.GetDelegateForFunctionPointer<NetCoreImportDelegate>( nativeInitPtr );
			if ( nativeInit == null ) throw new System.Exception( "Couldn't load from tools/libhammer.so" );
			
			var managedFunctions = new IntPtr[61]
			
			{
				(IntPtr) (delegate* unmanaged<int, IntPtr, void>) &Exports.dtrMpdtr_BlockToolGlue_BuildGeometry,
				(IntPtr) (delegate* unmanaged<IntPtr, IntPtr>) &Exports.dtrMpdtr_BlockToolGlue_BuildUI,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_BlockToolGlue_SetInProgress,
				(IntPtr) (delegate* unmanaged<IntPtr, void>) &Exports.dtrMpdtr_BlockToolGlue_SetOverrideEntity,
				(IntPtr) (delegate* unmanaged<IntPtr, uint>) &Exports.dtrMpdtr_EntityToolGlue_Create,
				(IntPtr) (delegate* unmanaged<IntPtr, void>) &Exports.dtrMpdtr_Hammer_Init,
				(IntPtr) (delegate* unmanaged<void>) &Exports.dtrMpdtr_Hammer_RunFrame,
				(IntPtr) (delegate* unmanaged<void>) &Exports.dtrMpdtr_Hammer_Shutdown,
				(IntPtr) (delegate* unmanaged<IntPtr, void>) &Exports.dtrMpdtr_Hammer_UpdateActiveMaterial,
				(IntPtr) (delegate* unmanaged<int, IntPtr, void>) &Exports.dtrMpdtr_Hammer_RenderMapViewHUD,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_Hammer_PreSaveMap,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_Hammer_PostLoadMap,
				(IntPtr) (delegate* unmanaged<int, int, void>) &Exports.dtrMpdtr_Hammer_MapAssetSaved,
				(IntPtr) (delegate* unmanaged<int, IntPtr, void>) &Exports.dtrMpdtr_Hammer_OnMapViewOpenContextMenu,
				(IntPtr) (delegate* unmanaged<void>) &Exports.dtrMpdtr_Hammer_OnCreateGameObjectMenu,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_HammerEvents_OnMapNodeDescriptionChanged,
				(IntPtr) (delegate* unmanaged<int, int, void>) &Exports.dtrMpdtr_HammerEvents_OnObjectAddedToDocument,
				(IntPtr) (delegate* unmanaged<int, int, void>) &Exports.dtrMpdtr_HammerEvents_OnObjectRemovedFromDocument,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_HammerEvents_OnMeshesTiedToGameObject,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.dtrMpdtr_HammerMainWindow_WindowInit,
				(IntPtr) (delegate* unmanaged<uint, IntPtr, IntPtr, IntPtr, IntPtr, long, long, float, void>) &Exports.dtrMpdtr_HammerMainWindow_AddNativeDock,
				(IntPtr) (delegate* unmanaged<uint, IntPtr, void>) &Exports.dtrMpdtr_HammerMainWindow_CreateDynamicViewMenu,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.dtrMpdtr_HammerMainWindow_ToggleAssetBrowser,
				(IntPtr) (delegate* unmanaged<uint, int, void>) &Exports.dtrMpdtr_HammerMainWindow_ToggleFullscreenLayout,
				(IntPtr) (delegate* unmanaged<IntPtr, uint>) &Exports.dtrMpdtr_HammerMainWindow_InitHammerMainWindow,
				(IntPtr) (delegate* unmanaged<IntPtr, uint>) &Exports.dtrMpdtr_HmmrMngdnspctr_Create,
				(IntPtr) (delegate* unmanaged<uint, int, int>) &Exports.dtrMpdtr_HmmrMngdnspctr_Inspect,
				(IntPtr) (delegate* unmanaged<uint, IntPtr>) &Exports.dtrMpdtr_HmmrMngdnspctr_GetWidget,
				(IntPtr) (delegate* unmanaged<IntPtr, IntPtr, uint>) &Exports.dtrMpdtr_HammerSession_Create,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.dtrMpdtr_HammerSession_Destroyed,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.dtrMpdtr_HammerSession_LaunchMapInEngine,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.dtrMpdtr_HammerSession_OnPreCompileFinished,
				(IntPtr) (delegate* unmanaged<uint, void>) &Exports.dtrMpdtr_HammerSession_OnPostCompileFinished,
				(IntPtr) (delegate* unmanaged<uint, int>) &Exports.dtrMpdtr_HammerSession_OnPaste,
				(IntPtr) (delegate* unmanaged<uint, IntPtr, void>) &Exports.dtrMpdtr_IEntityTool_CreateUI,
				(IntPtr) (delegate* unmanaged<uint, IntPtr>) &Exports.dtrMpdtr_IEntityTool_GetCurrentEntityClassName,
				(IntPtr) (delegate* unmanaged<uint, IntPtr, void>) &Exports.dtrMpdtr_IPathTool_CreateUI,
				(IntPtr) (delegate* unmanaged<uint, IntPtr>) &Exports.dtrMpdtr_IPathTool_GetCurrentEntityClassName,
				(IntPtr) (delegate* unmanaged<uint, float>) &Exports.dtrMpdtr_IPathTool_GetRadiusOffset,
				(IntPtr) (delegate* unmanaged<uint, int>) &Exports.dtrMpdtr_IPathTool_IsRadiusOffsetEnabled,
				(IntPtr) (delegate* unmanaged<int, int, void>) &Exports.dtrMpdtr_MapNodeCallbacks_OnAddToWorld,
				(IntPtr) (delegate* unmanaged<int, int, void>) &Exports.dtrMpdtr_MapNodeCallbacks_OnRemoveFromWorld,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_MapNodeCallbacks_PreSaveToFile,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_MapNodeCallbacks_PostLoadFromFile,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_MapNodeCallbacks_PostLoadDocument,
				(IntPtr) (delegate* unmanaged<int, int, int, void>) &Exports.dtrMpdtr_MapNodeCallbacks_OnCopyFrom,
				(IntPtr) (delegate* unmanaged<int, int, void>) &Exports.dtrMpdtr_MapNodeCallbacks_OnParentChanged,
				(IntPtr) (delegate* unmanaged<int, Vector3, Angles, Vector3, void>) &Exports.dtrMpdtr_MapNodeCallbacks_OnTransformChanged,
				(IntPtr) (delegate* unmanaged<int, int, void>) &Exports.dtrMpdtr_MapNodeCallbacks_OnSetEnabled,
				(IntPtr) (delegate* unmanaged<int, IntPtr, void>) &Exports.dtrMpdtr_MapNodeCallbacks_GetMimeData,
				(IntPtr) (delegate* unmanaged<int, IntPtr>) &Exports.dtrMpdtr_MapNodeCallbacks_GetGameObjectName,
				(IntPtr) (delegate* unmanaged<int, IntPtr, void>) &Exports.dtrMpdtr_MapNodeCallbacks_GetWorldResourceReferencesAndDependencies,
				(IntPtr) (delegate* unmanaged<IntPtr, int, int>) &Exports.dtrMpdtr_MpVwDrpTrgt_OnDragEnter,
				(IntPtr) (delegate* unmanaged<IntPtr, int, int>) &Exports.dtrMpdtr_MpVwDrpTrgt_OnDragMove,
				(IntPtr) (delegate* unmanaged<IntPtr, int, int>) &Exports.dtrMpdtr_MpVwDrpTrgt_OnDrop,
				(IntPtr) (delegate* unmanaged<int, void>) &Exports.dtrMpdtr_MpVwDrpTrgt_OnDragLeave,
				(IntPtr) (delegate* unmanaged<int>) &Exports.dtrMpdtr_MpVwDrpTrgt_GetDragAndDropActive,
				(IntPtr) (delegate* unmanaged<int, IntPtr, void>) &Exports.dtrMpdtr_MapViewRender_OnPreRender,
				(IntPtr) (delegate* unmanaged<int, Vector2, IntPtr, int>) &Exports.dtrMpdtr_MapViewRender_TraceManagedGizmos,
				(IntPtr) (delegate* unmanaged<uint>) &Exports.dtrMpdtr_PathToolGlue_Create,
				(IntPtr) (delegate* unmanaged<void>) &Exports.dtrMpdtr_Selection_OnSelectionChanged,
			};
			
			var nativeFunctions = new IntPtr[616];
			
			var structSizes = new int[]
			
			{
				sizeof( Editor.DockArea ),
				sizeof( NativeMapDoc.EnumChildrenPos ),
				sizeof( NativeHammer.HitInfo_t ),
				sizeof( NativeHammer.ManipulationMode_t ),
				sizeof( Editor.MapDoc.MapNodeGetRootDocument ),
				sizeof( NativeMapDoc.SelectionConversionMethod_t ),
				sizeof( NativeMapDoc.SelectionOperation_t ),
				sizeof( Editor.MapEditor.SelectMode ),
				sizeof( NativeHammer.TraceRequest ),
				sizeof( NativeHammer.TraceResult ),
				sizeof( Editor.MapDoc.TransformFlags ),
				sizeof( Editor.MapDoc.TransformOperationMode ),
			};
			
			
			fixed ( void* m = managedFunctions )
			fixed ( void* n = nativeFunctions )
			fixed ( int* s = structSizes )
			
			{
				nativeInit( 55867, m, n, s );
			}
			
			var onError = Marshal.GetDelegateForFunctionPointer<_ErrorFunction>( nativeFunctions[0] );
			
			try
			{
				NativeHammer.CHammerApp.__N.CHammerApp_RefreshEntitiesGameData = (delegate* unmanaged< IntPtr, void >) nativeFunctions[1];
				NativeHammer.CHammerApp.__N.CHammerApp_GetCurrentMaterial = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[2];
				NativeHammer.CHammerApp.__N.CHammerApp_SetCurrentTexture = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[3];
				NativeHammer.CHammerApp.__N.CHammerApp_GetActiveMapAsset = (delegate* unmanaged< IntPtr, int >) nativeFunctions[4];
				NativeHammer.CHammerApp.__N.CHammerApp_GetActiveMapDoc = (delegate* unmanaged< IntPtr, int >) nativeFunctions[5];
				NativeHammer.CHammerApp.__N.CHammerApp_MarkAllViewHudsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[6];
				NativeHammer.CHammerApp.__N.CHammerApp_SelectObjectsUsingAsset = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[7];
				NativeHammer.CHammerApp.__N.CHammerApp_SelectFacesUsingMaterial = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[8];
				NativeHammer.CHammerApp.__N.CHammerApp_AssignAssetToSelection = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[9];
				NativeHammer.CHammerApp.__N.CHammerApp_ShowEntityReportForAsset = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[10];
				NativeHammer.CHammerApp.__N.CHammerApp_OnFileReload = (delegate* unmanaged< IntPtr, void >) nativeFunctions[11];
				CHammerEditorSession.__N.CHmmrdtrSssn_ShowLoadingProgressBar = (delegate* unmanaged< IntPtr, void >) nativeFunctions[12];
				CHammerEditorSession.__N.CHmmrdtrSssn_HideLoadingProgressBar = (delegate* unmanaged< IntPtr, void >) nativeFunctions[13];
				CHammerEditorSession.__N.CHmmrdtrSssn_GetMapAsset = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[14];
				CHammerEditorSession.__N.CHmmrdtrSssn_GetMapDoc = (delegate* unmanaged< IntPtr, int >) nativeFunctions[15];
				NativeHammer.CHistory.__N.CHistory_MarkUndoPosition = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, void >) nativeFunctions[16];
				NativeHammer.CHistory.__N.CHistory_Keep = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[17];
				NativeHammer.CHistory.__N.CHistory_KeepNew = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[18];
				NativeHammer.CHistory.__N.CHistory_GetHistory = (delegate* unmanaged< IntPtr >) nativeFunctions[19];
				NativeMapDoc.CMapDoc.__N.CMapDoc_GetMapWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[20];
				NativeMapDoc.CMapDoc.__N.CMapDoc_GetPathName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[21];
				NativeMapDoc.CMapDoc.__N.CMapDoc_GetSelection = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[22];
				NativeMapDoc.CMapDoc.__N.CMapDoc_AddObjectToDocument = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, void >) nativeFunctions[23];
				NativeMapDoc.CMapDoc.__N.CMapDoc_DeleteObject = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[24];
				NativeMapDoc.CMapDoc.__N.CMapDoc_CreateEmptyMesh = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[25];
				NativeMapDoc.CMapDoc.__N.CMapDoc_CreateEntity = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[26];
				NativeMapDoc.CMapDoc.__N.CMapDoc_CreateGameObject = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[27];
				NativeMapDoc.CMapDoc.__N.CMapDoc_CreateMapGroup = (delegate* unmanaged< IntPtr, void >) nativeFunctions[28];
				NativeMapDoc.CMapDoc.__N.CMapDoc_CreateMapInstance = (delegate* unmanaged< IntPtr, void >) nativeFunctions[29];
				NativeMapDoc.CMapDoc.__N.CMapDoc_CreateMapPath = (delegate* unmanaged< IntPtr, void >) nativeFunctions[30];
				NativeMapDoc.CMapDoc.__N.CMapDoc_CreateStaticOverlay = (delegate* unmanaged< IntPtr, void >) nativeFunctions[31];
				NativeMapDoc.CMapEntity.__N.From_CMapNode_To_CMapEntity = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[32];
				NativeMapDoc.CMapEntity.__N.To_CMapNode_From_CMapEntity = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[33];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetClassName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[34];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetClass = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[35];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetKeyValue = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, void >) nativeFunctions[36];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetKeyValue = (delegate* unmanaged< IntPtr, IntPtr, IntPtr >) nativeFunctions[37];
				NativeMapDoc.CMapEntity.__N.CMapEntity_TargetNameMatches = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[38];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetDefaultBounds = (delegate* unmanaged< IntPtr, Vector3*, Vector3*, void >) nativeFunctions[39];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[40];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[41];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[42];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[43];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[44];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[45];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[46];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[47];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[48];
				NativeMapDoc.CMapEntity.__N.CMapEntity_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[49];
				NativeMapDoc.CMapEntity.__N.CMapEntity_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[50];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[51];
				NativeMapDoc.CMapEntity.__N.CMapEntity_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[52];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[53];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[54];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[55];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[56];
				NativeMapDoc.CMapEntity.__N.CMapEntity_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[57];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[58];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[59];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[60];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[61];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[62];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[63];
				NativeMapDoc.CMapEntity.__N.CMapEntity_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[64];
				NativeMapDoc.CMapEntity.__N.CMapEntity_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[65];
				NativeMapDoc.CMapEntity.__N.CMapEntity_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[66];
				NativeMapDoc.CMapEntity.__N.CMapEntity_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[67];
				NativeMapDoc.CMapEntity.__N.CMapEntity_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[68];
				NativeMapDoc.CMapEntity.__N.CMapEntity_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[69];
				NativeMapDoc.CMapEntity.__N.CMapEntity_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[70];
				NativeMapDoc.CMapEntity.__N.CMapEntity_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[71];
				NativeMapDoc.CMapEntity.__N.CMapEntity_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[72];
				NativeMapDoc.CMapGameObject.__N.From_CMapNode_To_CMapGameObject = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[73];
				NativeMapDoc.CMapGameObject.__N.To_CMapNode_From_CMapGameObject = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[74];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_SetGUID = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[75];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetGUID = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[76];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[77];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[78];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[79];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[80];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[81];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[82];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[83];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[84];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[85];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[86];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[87];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[88];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[89];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[90];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[91];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[92];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[93];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[94];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[95];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[96];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[97];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[98];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[99];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[100];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[101];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[102];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[103];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[104];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[105];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[106];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[107];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[108];
				NativeMapDoc.CMapGameObject.__N.CMapGameObject_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[109];
				NativeMapDoc.CMapGroup.__N.From_CMapNode_To_CMapGroup = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[110];
				NativeMapDoc.CMapGroup.__N.To_CMapNode_From_CMapGroup = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[111];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[112];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[113];
				NativeMapDoc.CMapGroup.__N.CMapGroup_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[114];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[115];
				NativeMapDoc.CMapGroup.__N.CMapGroup_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[116];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[117];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[118];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[119];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[120];
				NativeMapDoc.CMapGroup.__N.CMapGroup_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[121];
				NativeMapDoc.CMapGroup.__N.CMapGroup_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[122];
				NativeMapDoc.CMapGroup.__N.CMapGroup_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[123];
				NativeMapDoc.CMapGroup.__N.CMapGroup_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[124];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[125];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[126];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[127];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[128];
				NativeMapDoc.CMapGroup.__N.CMapGroup_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[129];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[130];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[131];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[132];
				NativeMapDoc.CMapGroup.__N.CMapGroup_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[133];
				NativeMapDoc.CMapGroup.__N.CMapGroup_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[134];
				NativeMapDoc.CMapGroup.__N.CMapGroup_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[135];
				NativeMapDoc.CMapGroup.__N.CMapGroup_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[136];
				NativeMapDoc.CMapGroup.__N.CMapGroup_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[137];
				NativeMapDoc.CMapGroup.__N.CMapGroup_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[138];
				NativeMapDoc.CMapGroup.__N.CMapGroup_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[139];
				NativeMapDoc.CMapGroup.__N.CMapGroup_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[140];
				NativeMapDoc.CMapGroup.__N.CMapGroup_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[141];
				NativeMapDoc.CMapGroup.__N.CMapGroup_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[142];
				NativeMapDoc.CMapGroup.__N.CMapGroup_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[143];
				NativeMapDoc.CMapGroup.__N.CMapGroup_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[144];
				NativeMapDoc.CMapInstance.__N.From_CMapNode_To_CMapInstance = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[145];
				NativeMapDoc.CMapInstance.__N.To_CMapNode_From_CMapInstance = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[146];
				NativeMapDoc.CMapInstance.__N.CMapInstance_SetTarget = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[147];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetTarget = (delegate* unmanaged< IntPtr, int >) nativeFunctions[148];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[149];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[150];
				NativeMapDoc.CMapInstance.__N.CMapInstance_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[151];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[152];
				NativeMapDoc.CMapInstance.__N.CMapInstance_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[153];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[154];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[155];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[156];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[157];
				NativeMapDoc.CMapInstance.__N.CMapInstance_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[158];
				NativeMapDoc.CMapInstance.__N.CMapInstance_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[159];
				NativeMapDoc.CMapInstance.__N.CMapInstance_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[160];
				NativeMapDoc.CMapInstance.__N.CMapInstance_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[161];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[162];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[163];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[164];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[165];
				NativeMapDoc.CMapInstance.__N.CMapInstance_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[166];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[167];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[168];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[169];
				NativeMapDoc.CMapInstance.__N.CMapInstance_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[170];
				NativeMapDoc.CMapInstance.__N.CMapInstance_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[171];
				NativeMapDoc.CMapInstance.__N.CMapInstance_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[172];
				NativeMapDoc.CMapInstance.__N.CMapInstance_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[173];
				NativeMapDoc.CMapInstance.__N.CMapInstance_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[174];
				NativeMapDoc.CMapInstance.__N.CMapInstance_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[175];
				NativeMapDoc.CMapInstance.__N.CMapInstance_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[176];
				NativeMapDoc.CMapInstance.__N.CMapInstance_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[177];
				NativeMapDoc.CMapInstance.__N.CMapInstance_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[178];
				NativeMapDoc.CMapInstance.__N.CMapInstance_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[179];
				NativeMapDoc.CMapInstance.__N.CMapInstance_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[180];
				NativeMapDoc.CMapInstance.__N.CMapInstance_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[181];
				NativeMapDoc.CMapMesh.__N.From_CMapNode_To_CMapMesh = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[182];
				NativeMapDoc.CMapMesh.__N.To_CMapNode_From_CMapMesh = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[183];
				NativeMapDoc.CMapMesh.__N.CMapMesh_AssignMaterialToMesh = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[184];
				NativeMapDoc.CMapMesh.__N.CMapMesh_ConstructFromData = (delegate* unmanaged< IntPtr, int, IntPtr, IntPtr, int, IntPtr, int, IntPtr, IntPtr, int, float, void >) nativeFunctions[185];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetFaceMaterials = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[186];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[187];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[188];
				NativeMapDoc.CMapMesh.__N.CMapMesh_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[189];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[190];
				NativeMapDoc.CMapMesh.__N.CMapMesh_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[191];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[192];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[193];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[194];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[195];
				NativeMapDoc.CMapMesh.__N.CMapMesh_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[196];
				NativeMapDoc.CMapMesh.__N.CMapMesh_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[197];
				NativeMapDoc.CMapMesh.__N.CMapMesh_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[198];
				NativeMapDoc.CMapMesh.__N.CMapMesh_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[199];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[200];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[201];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[202];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[203];
				NativeMapDoc.CMapMesh.__N.CMapMesh_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[204];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[205];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[206];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[207];
				NativeMapDoc.CMapMesh.__N.CMapMesh_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[208];
				NativeMapDoc.CMapMesh.__N.CMapMesh_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[209];
				NativeMapDoc.CMapMesh.__N.CMapMesh_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[210];
				NativeMapDoc.CMapMesh.__N.CMapMesh_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[211];
				NativeMapDoc.CMapMesh.__N.CMapMesh_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[212];
				NativeMapDoc.CMapMesh.__N.CMapMesh_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[213];
				NativeMapDoc.CMapMesh.__N.CMapMesh_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[214];
				NativeMapDoc.CMapMesh.__N.CMapMesh_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[215];
				NativeMapDoc.CMapMesh.__N.CMapMesh_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[216];
				NativeMapDoc.CMapMesh.__N.CMapMesh_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[217];
				NativeMapDoc.CMapMesh.__N.CMapMesh_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[218];
				NativeMapDoc.CMapMesh.__N.CMapMesh_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[219];
				NativeMapDoc.CMapNode.__N.CMapNode_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[220];
				NativeMapDoc.CMapNode.__N.CMapNode_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[221];
				NativeMapDoc.CMapNode.__N.CMapNode_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[222];
				NativeMapDoc.CMapNode.__N.CMapNode_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[223];
				NativeMapDoc.CMapNode.__N.CMapNode_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[224];
				NativeMapDoc.CMapNode.__N.CMapNode_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[225];
				NativeMapDoc.CMapNode.__N.CMapNode_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[226];
				NativeMapDoc.CMapNode.__N.CMapNode_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[227];
				NativeMapDoc.CMapNode.__N.CMapNode_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[228];
				NativeMapDoc.CMapNode.__N.CMapNode_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[229];
				NativeMapDoc.CMapNode.__N.CMapNode_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[230];
				NativeMapDoc.CMapNode.__N.CMapNode_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[231];
				NativeMapDoc.CMapNode.__N.CMapNode_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[232];
				NativeMapDoc.CMapNode.__N.CMapNode_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[233];
				NativeMapDoc.CMapNode.__N.CMapNode_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[234];
				NativeMapDoc.CMapNode.__N.CMapNode_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[235];
				NativeMapDoc.CMapNode.__N.CMapNode_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[236];
				NativeMapDoc.CMapNode.__N.CMapNode_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[237];
				NativeMapDoc.CMapNode.__N.CMapNode_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[238];
				NativeMapDoc.CMapNode.__N.CMapNode_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[239];
				NativeMapDoc.CMapNode.__N.CMapNode_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[240];
				NativeMapDoc.CMapNode.__N.CMapNode_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[241];
				NativeMapDoc.CMapNode.__N.CMapNode_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[242];
				NativeMapDoc.CMapNode.__N.CMapNode_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[243];
				NativeMapDoc.CMapNode.__N.CMapNode_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[244];
				NativeMapDoc.CMapNode.__N.CMapNode_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[245];
				NativeMapDoc.CMapNode.__N.CMapNode_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[246];
				NativeMapDoc.CMapNode.__N.CMapNode_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[247];
				NativeMapDoc.CMapNode.__N.CMapNode_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[248];
				NativeMapDoc.CMapNode.__N.CMapNode_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[249];
				NativeMapDoc.CMapNode.__N.CMapNode_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[250];
				NativeMapDoc.CMapNode.__N.CMapNode_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[251];
				NativeMapDoc.CMapNode.__N.CMapNode_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[252];
				NativeMapDoc.CMapPath.__N.From_CMapEntity_To_CMapPath = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[253];
				NativeMapDoc.CMapPath.__N.To_CMapEntity_From_CMapPath = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[254];
				NativeMapDoc.CMapPath.__N.From_CMapNode_To_CMapPath = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[255];
				NativeMapDoc.CMapPath.__N.To_CMapNode_From_CMapPath = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[256];
				NativeMapDoc.CMapPath.__N.CMapPath_AddNewNodeToPath = (delegate* unmanaged< IntPtr, int >) nativeFunctions[257];
				NativeMapDoc.CMapPath.__N.CMapPath_GetClassName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[258];
				NativeMapDoc.CMapPath.__N.CMapPath_SetClass = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[259];
				NativeMapDoc.CMapPath.__N.CMapPath_SetKeyValue = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, void >) nativeFunctions[260];
				NativeMapDoc.CMapPath.__N.CMapPath_GetKeyValue = (delegate* unmanaged< IntPtr, IntPtr, IntPtr >) nativeFunctions[261];
				NativeMapDoc.CMapPath.__N.CMapPath_TargetNameMatches = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[262];
				NativeMapDoc.CMapPath.__N.CMapPath_SetDefaultBounds = (delegate* unmanaged< IntPtr, Vector3*, Vector3*, void >) nativeFunctions[263];
				NativeMapDoc.CMapPath.__N.CMapPath_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[264];
				NativeMapDoc.CMapPath.__N.CMapPath_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[265];
				NativeMapDoc.CMapPath.__N.CMapPath_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[266];
				NativeMapDoc.CMapPath.__N.CMapPath_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[267];
				NativeMapDoc.CMapPath.__N.CMapPath_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[268];
				NativeMapDoc.CMapPath.__N.CMapPath_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[269];
				NativeMapDoc.CMapPath.__N.CMapPath_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[270];
				NativeMapDoc.CMapPath.__N.CMapPath_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[271];
				NativeMapDoc.CMapPath.__N.CMapPath_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[272];
				NativeMapDoc.CMapPath.__N.CMapPath_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[273];
				NativeMapDoc.CMapPath.__N.CMapPath_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[274];
				NativeMapDoc.CMapPath.__N.CMapPath_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[275];
				NativeMapDoc.CMapPath.__N.CMapPath_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[276];
				NativeMapDoc.CMapPath.__N.CMapPath_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[277];
				NativeMapDoc.CMapPath.__N.CMapPath_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[278];
				NativeMapDoc.CMapPath.__N.CMapPath_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[279];
				NativeMapDoc.CMapPath.__N.CMapPath_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[280];
				NativeMapDoc.CMapPath.__N.CMapPath_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[281];
				NativeMapDoc.CMapPath.__N.CMapPath_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[282];
				NativeMapDoc.CMapPath.__N.CMapPath_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[283];
				NativeMapDoc.CMapPath.__N.CMapPath_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[284];
				NativeMapDoc.CMapPath.__N.CMapPath_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[285];
				NativeMapDoc.CMapPath.__N.CMapPath_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[286];
				NativeMapDoc.CMapPath.__N.CMapPath_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[287];
				NativeMapDoc.CMapPath.__N.CMapPath_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[288];
				NativeMapDoc.CMapPath.__N.CMapPath_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[289];
				NativeMapDoc.CMapPath.__N.CMapPath_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[290];
				NativeMapDoc.CMapPath.__N.CMapPath_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[291];
				NativeMapDoc.CMapPath.__N.CMapPath_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[292];
				NativeMapDoc.CMapPath.__N.CMapPath_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[293];
				NativeMapDoc.CMapPath.__N.CMapPath_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[294];
				NativeMapDoc.CMapPath.__N.CMapPath_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[295];
				NativeMapDoc.CMapPath.__N.CMapPath_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[296];
				NativeMapDoc.CMapPathNode.__N.From_CMapEntity_To_CMapPathNode = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[297];
				NativeMapDoc.CMapPathNode.__N.To_CMapEntity_From_CMapPathNode = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[298];
				NativeMapDoc.CMapPathNode.__N.From_CMapNode_To_CMapPathNode = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[299];
				NativeMapDoc.CMapPathNode.__N.To_CMapNode_From_CMapPathNode = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[300];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetClassName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[301];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetClass = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[302];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetKeyValue = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, void >) nativeFunctions[303];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetKeyValue = (delegate* unmanaged< IntPtr, IntPtr, IntPtr >) nativeFunctions[304];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_TargetNameMatches = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[305];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetDefaultBounds = (delegate* unmanaged< IntPtr, Vector3*, Vector3*, void >) nativeFunctions[306];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[307];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[308];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[309];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[310];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[311];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[312];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[313];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[314];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[315];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[316];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[317];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[318];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[319];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[320];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[321];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[322];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[323];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[324];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[325];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[326];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[327];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[328];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[329];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[330];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[331];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[332];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[333];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[334];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[335];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[336];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[337];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[338];
				NativeMapDoc.CMapPathNode.__N.CMapPathNode_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[339];
				NativeMapDoc.CMapStaticOverlay.__N.From_CMapMesh_To_CMapStaticOverlay = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[340];
				NativeMapDoc.CMapStaticOverlay.__N.To_CMapMesh_From_CMapStaticOverlay = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[341];
				NativeMapDoc.CMapStaticOverlay.__N.From_CMapNode_To_CMapStaticOverlay = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[342];
				NativeMapDoc.CMapStaticOverlay.__N.To_CMapNode_From_CMapStaticOverlay = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[343];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_CreateCenteredQuad = (delegate* unmanaged< IntPtr, float, float, IntPtr, void >) nativeFunctions[344];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_AssignMaterialToMesh = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[345];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_ConstructFromData = (delegate* unmanaged< IntPtr, int, IntPtr, IntPtr, int, IntPtr, int, IntPtr, IntPtr, int, float, void >) nativeFunctions[346];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetFaceMaterials = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[347];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[348];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[349];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[350];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[351];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[352];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[353];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[354];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[355];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[356];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[357];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[358];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[359];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[360];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[361];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[362];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[363];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[364];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[365];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[366];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[367];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[368];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[369];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[370];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[371];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[372];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[373];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[374];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[375];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[376];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[377];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[378];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[379];
				NativeMapDoc.CMapStaticOverlay.__N.CMpSttcvrly_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[380];
				NativeHammer.CMapView.__N.CMapView_GetMapDoc = (delegate* unmanaged< IntPtr, int >) nativeFunctions[381];
				NativeHammer.CMapView.__N.CMapView_MarkHudDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[382];
				NativeHammer.CMapView.__N.CMapView_GetCamera = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[383];
				NativeHammer.CMapView.__N.CMapView_IsActive = (delegate* unmanaged< IntPtr, int >) nativeFunctions[384];
				NativeHammer.CMapView.__N.CMapView_GetMousePosition = (delegate* unmanaged< IntPtr, out Vector2, void >) nativeFunctions[385];
				NativeHammer.CMapView.__N.CMapView_EnterFreeDragMode = (delegate* unmanaged< IntPtr, Vector2*, IntPtr, Vector3*, int, void >) nativeFunctions[386];
				NativeHammer.CMapView.__N.CMapView_UpdateFreeDragMode = (delegate* unmanaged< IntPtr, Vector2*, int, void >) nativeFunctions[387];
				NativeHammer.CMapView.__N.CMapView_ExitFreeDragMode = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[388];
				NativeHammer.CMapView.__N.CMapView_GetDropTarget = (delegate* unmanaged< IntPtr, ref Vector3, ref Vector3, Vector2*, void >) nativeFunctions[389];
				NativeHammer.CMapView.__N.CMapView_UpdateManagedGizmoState = (delegate* unmanaged< IntPtr, int, float, void >) nativeFunctions[390];
				NativeHammer.CMapView.__N.CMapView_GetManipulationMode = (delegate* unmanaged< IntPtr, long >) nativeFunctions[391];
				NativeHammer.CMapView.__N.CMapView_HitDistanceAtMouse = (delegate* unmanaged< IntPtr, float >) nativeFunctions[392];
				NativeMapDoc.CMapWorld.__N.From_CMapNode_To_CMapWorld = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[393];
				NativeMapDoc.CMapWorld.__N.To_CMapNode_From_CMapWorld = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[394];
				NativeMapDoc.CMapWorld.__N.CMapWorld_SetSerializedScene = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[395];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetSerializedScene = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[396];
				NativeMapDoc.CMapWorld.__N.CMapWorld_FindNodeByID = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[397];
				NativeMapDoc.CMapWorld.__N.CMapWorld_FindEntityByNodeId = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[398];
				NativeMapDoc.CMapWorld.__N.CMapWorld_Trace = (delegate* unmanaged< IntPtr, NativeHammer.TraceRequest*, NativeHammer.TraceResult >) nativeFunctions[399];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetNodeID = (delegate* unmanaged< IntPtr, int >) nativeFunctions[400];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[401];
				NativeMapDoc.CMapWorld.__N.CMapWorld_SetName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[402];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetParent = (delegate* unmanaged< IntPtr, int >) nativeFunctions[403];
				NativeMapDoc.CMapWorld.__N.CMapWorld_SetParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[404];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetParentWorld = (delegate* unmanaged< IntPtr, int >) nativeFunctions[405];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetRootDocument = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[406];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetDescription = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[407];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetTypeString = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[408];
				NativeMapDoc.CMapWorld.__N.CMapWorld_Copy = (delegate* unmanaged< IntPtr, int >) nativeFunctions[409];
				NativeMapDoc.CMapWorld.__N.CMapWorld_IsVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[410];
				NativeMapDoc.CMapWorld.__N.CMapWorld_SetVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[411];
				NativeMapDoc.CMapWorld.__N.CMapWorld_IsSelected = (delegate* unmanaged< IntPtr, int >) nativeFunctions[412];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetChildCount = (delegate* unmanaged< IntPtr, int >) nativeFunctions[413];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetChild = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[414];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetFirstDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[415];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetNextDescendent = (delegate* unmanaged< IntPtr, ref NativeMapDoc.EnumChildrenPos, int >) nativeFunctions[416];
				NativeMapDoc.CMapWorld.__N.CMapWorld_AsMapEntity = (delegate* unmanaged< IntPtr, int >) nativeFunctions[417];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[418];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[419];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GetScales = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[420];
				NativeMapDoc.CMapWorld.__N.CMapWorld_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[421];
				NativeMapDoc.CMapWorld.__N.CMapWorld_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[422];
				NativeMapDoc.CMapWorld.__N.CMapWorld_SetScales = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[423];
				NativeMapDoc.CMapWorld.__N.CMapWorld_BeginTransformOperation = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[424];
				NativeMapDoc.CMapWorld.__N.CMapWorld_Transform = (delegate* unmanaged< IntPtr, Matrix*, long, void >) nativeFunctions[425];
				NativeMapDoc.CMapWorld.__N.CMapWorld_EndTransformOperation = (delegate* unmanaged< IntPtr, void >) nativeFunctions[426];
				NativeMapDoc.CMapWorld.__N.CMapWorld_MarkBoundsDirty = (delegate* unmanaged< IntPtr, void >) nativeFunctions[427];
				NativeMapDoc.CMapWorld.__N.CMapWorld_FullBoundsUpdate = (delegate* unmanaged< IntPtr, void >) nativeFunctions[428];
				NativeMapDoc.CMapWorld.__N.CMapWorld_SetModifiedFlag = (delegate* unmanaged< IntPtr, void >) nativeFunctions[429];
				NativeMapDoc.CMapWorld.__N.CMapWorld_GeneratesEntityModelGeometry = (delegate* unmanaged< IntPtr, int >) nativeFunctions[430];
				NativeMapDoc.CMapWorld.__N.CMapWorld_DescriptionChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[431];
				NativeMapDoc.CMapWorld.__N.CMapWorld_CoreAttributeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[432];
				Native.CQHammerMainWnd.__N.From_CFramelessMainWindow_To_CQHammerMainWnd = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[433];
				Native.CQHammerMainWnd.__N.To_CFramelessMainWindow_From_CQHammerMainWnd = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[434];
				Native.CQHammerMainWnd.__N.From_QMainWindow_To_CQHammerMainWnd = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[435];
				Native.CQHammerMainWnd.__N.To_QMainWindow_From_CQHammerMainWnd = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[436];
				Native.CQHammerMainWnd.__N.From_QWidget_To_CQHammerMainWnd = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[437];
				Native.CQHammerMainWnd.__N.To_QWidget_From_CQHammerMainWnd = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[438];
				Native.CQHammerMainWnd.__N.From_QObject_To_CQHammerMainWnd = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[439];
				Native.CQHammerMainWnd.__N.To_QObject_From_CQHammerMainWnd = (delegate* unmanaged[SuppressGCTransition]< IntPtr, IntPtr >) nativeFunctions[440];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_CreateEverything = (delegate* unmanaged< IntPtr, void >) nativeFunctions[441];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_CreateMenus = (delegate* unmanaged< IntPtr, void >) nativeFunctions[442];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_SetupDefaultLayout = (delegate* unmanaged< IntPtr, void >) nativeFunctions[443];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_SetTitleBarWidgets = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, void >) nativeFunctions[444];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_iconSize = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[445];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setIconSize = (delegate* unmanaged< IntPtr, Vector3, void >) nativeFunctions[446];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_menuBar = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[447];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setMenuBar = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[448];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setMenuWidget = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[449];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_statusBar = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[450];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setStatusBar = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[451];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_centralWidget = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[452];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setCentralWidget = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[453];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isAnimated = (delegate* unmanaged< IntPtr, int >) nativeFunctions[454];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setAnimated = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[455];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_addToolBarBreak = (delegate* unmanaged< IntPtr, long, void >) nativeFunctions[456];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_insertToolBarBreak = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[457];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_addToolBar = (delegate* unmanaged< IntPtr, long, IntPtr, void >) nativeFunctions[458];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_addToolBar_1 = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[459];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_insertToolBar = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, void >) nativeFunctions[460];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_removeToolBar = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[461];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_removeToolBarBreak = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[462];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_saveState = (delegate* unmanaged< IntPtr, int, IntPtr >) nativeFunctions[463];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_restoreState = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[464];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isTopLevel = (delegate* unmanaged< IntPtr, int >) nativeFunctions[465];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isWindow = (delegate* unmanaged< IntPtr, int >) nativeFunctions[466];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isModal = (delegate* unmanaged< IntPtr, int >) nativeFunctions[467];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setStyleSheet = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[468];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_windowTitle = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[469];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setWindowTitle = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[470];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setWindowFlags = (delegate* unmanaged< IntPtr, long, void >) nativeFunctions[471];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_windowFlags = (delegate* unmanaged< IntPtr, long >) nativeFunctions[472];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_size = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[473];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_resize = (delegate* unmanaged< IntPtr, Vector3, void >) nativeFunctions[474];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_minimumSize = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[475];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setMinimumSize = (delegate* unmanaged< IntPtr, Vector3, void >) nativeFunctions[476];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_maximumSize = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[477];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setMaximumSize = (delegate* unmanaged< IntPtr, Vector3, void >) nativeFunctions[478];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_sizeHint = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[479];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_pos = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[480];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_move = (delegate* unmanaged< IntPtr, Vector3, void >) nativeFunctions[481];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isEnabled = (delegate* unmanaged< IntPtr, int >) nativeFunctions[482];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setEnabled = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[483];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setVisible = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[484];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_show = (delegate* unmanaged< IntPtr, void >) nativeFunctions[485];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_hide = (delegate* unmanaged< IntPtr, void >) nativeFunctions[486];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_showMinimized = (delegate* unmanaged< IntPtr, void >) nativeFunctions[487];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_showMaximized = (delegate* unmanaged< IntPtr, void >) nativeFunctions[488];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_showFullScreen = (delegate* unmanaged< IntPtr, void >) nativeFunctions[489];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_showNormal = (delegate* unmanaged< IntPtr, void >) nativeFunctions[490];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_close = (delegate* unmanaged< IntPtr, int >) nativeFunctions[491];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_raise = (delegate* unmanaged< IntPtr, void >) nativeFunctions[492];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_lower = (delegate* unmanaged< IntPtr, void >) nativeFunctions[493];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isVisible = (delegate* unmanaged< IntPtr, int >) nativeFunctions[494];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isHidden = (delegate* unmanaged< IntPtr, int >) nativeFunctions[495];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setHidden = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[496];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setAttribute = (delegate* unmanaged< IntPtr, long, int, void >) nativeFunctions[497];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_testAttribute = (delegate* unmanaged< IntPtr, long, int >) nativeFunctions[498];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_acceptDrops = (delegate* unmanaged< IntPtr, int >) nativeFunctions[499];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setAcceptDrops = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[500];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_updateGeometry = (delegate* unmanaged< IntPtr, void >) nativeFunctions[501];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_update = (delegate* unmanaged< IntPtr, void >) nativeFunctions[502];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_repaint = (delegate* unmanaged< IntPtr, void >) nativeFunctions[503];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setCursor = (delegate* unmanaged< IntPtr, long, void >) nativeFunctions[504];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setCursor_1 = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[505];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_unsetCursor = (delegate* unmanaged< IntPtr, void >) nativeFunctions[506];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setWindowIcon = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[507];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setWindowIconFromPixmap = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[508];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setWindowIconText = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[509];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setWindowOpacity = (delegate* unmanaged< IntPtr, float, void >) nativeFunctions[510];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_windowOpacity = (delegate* unmanaged< IntPtr, float >) nativeFunctions[511];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isMinimized = (delegate* unmanaged< IntPtr, int >) nativeFunctions[512];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isMaximized = (delegate* unmanaged< IntPtr, int >) nativeFunctions[513];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isFullScreen = (delegate* unmanaged< IntPtr, int >) nativeFunctions[514];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setMouseTracking = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[515];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_hasMouseTracking = (delegate* unmanaged< IntPtr, int >) nativeFunctions[516];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_underMouse = (delegate* unmanaged< IntPtr, int >) nativeFunctions[517];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_mapToGlobal = (delegate* unmanaged< IntPtr, Vector3, Vector3 >) nativeFunctions[518];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_mapFromGlobal = (delegate* unmanaged< IntPtr, Vector3, Vector3 >) nativeFunctions[519];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_hasFocus = (delegate* unmanaged< IntPtr, int >) nativeFunctions[520];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_focusPolicy = (delegate* unmanaged< IntPtr, long >) nativeFunctions[521];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setFocusPolicy = (delegate* unmanaged< IntPtr, long, void >) nativeFunctions[522];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setFocusProxy = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[523];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_isActiveWindow = (delegate* unmanaged< IntPtr, int >) nativeFunctions[524];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_updatesEnabled = (delegate* unmanaged< IntPtr, int >) nativeFunctions[525];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setUpdatesEnabled = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[526];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setFocus = (delegate* unmanaged< IntPtr, void >) nativeFunctions[527];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_activateWindow = (delegate* unmanaged< IntPtr, void >) nativeFunctions[528];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_clearFocus = (delegate* unmanaged< IntPtr, void >) nativeFunctions[529];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_devicePixelRatioF = (delegate* unmanaged< IntPtr, float >) nativeFunctions[530];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_saveGeometry = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[531];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_restoreGeometry = (delegate* unmanaged< IntPtr, IntPtr, int >) nativeFunctions[532];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_addAction = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[533];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_removeAction = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[534];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setParent = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[535];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_parentWidget = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[536];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_window = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[537];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_AddClassName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[538];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_Polish = (delegate* unmanaged< IntPtr, void >) nativeFunctions[539];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_toolTip = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[540];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setToolTip = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[541];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_statusTip = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[542];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setStatusTip = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[543];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_toolTipDuration = (delegate* unmanaged< IntPtr, int >) nativeFunctions[544];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setToolTipDuration = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[545];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_autoFillBackground = (delegate* unmanaged< IntPtr, int >) nativeFunctions[546];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setAutoFillBackground = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[547];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_adjustSize = (delegate* unmanaged< IntPtr, void >) nativeFunctions[548];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_windowModality = (delegate* unmanaged< IntPtr, long >) nativeFunctions[549];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setWindowModality = (delegate* unmanaged< IntPtr, long, void >) nativeFunctions[550];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_ScreenGeometry = (delegate* unmanaged< IntPtr, QRectF >) nativeFunctions[551];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setContentsMargins = (delegate* unmanaged< IntPtr, int, int, int, int, void >) nativeFunctions[552];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_contentsMargins = (delegate* unmanaged< IntPtr, QRectF >) nativeFunctions[553];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_layout = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[554];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setLayout = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[555];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_contentsRect = (delegate* unmanaged< IntPtr, QRectF >) nativeFunctions[556];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_SetEffectOpacity = (delegate* unmanaged< IntPtr, float, void >) nativeFunctions[557];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setSizePolicy = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[558];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_GetHorizontalSizePolicy = (delegate* unmanaged< IntPtr, long >) nativeFunctions[559];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_GetVerticalSizePolicy = (delegate* unmanaged< IntPtr, long >) nativeFunctions[560];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_SetHorizontalSizePolicy = (delegate* unmanaged< IntPtr, long, void >) nativeFunctions[561];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_SetVerticalSizePolicy = (delegate* unmanaged< IntPtr, long, void >) nativeFunctions[562];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setFixedSize = (delegate* unmanaged< IntPtr, int, int, void >) nativeFunctions[563];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setFixedWidth = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[564];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setFixedHeight = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[565];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_winId = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[566];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_deleteLater = (delegate* unmanaged< IntPtr, void >) nativeFunctions[567];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_objectName = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[568];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setObjectName = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[569];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setParent_1 = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[570];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setProperty = (delegate* unmanaged< IntPtr, IntPtr, int, void >) nativeFunctions[571];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setProperty_1 = (delegate* unmanaged< IntPtr, IntPtr, float, void >) nativeFunctions[572];
				Native.CQHammerMainWnd.__N.CQHammerMainWnd_setProperty_2 = (delegate* unmanaged< IntPtr, IntPtr, IntPtr, void >) nativeFunctions[573];
				NativeHammer.CSavedObjects.__N.CSavedObjects_DeleteThis = (delegate* unmanaged< IntPtr, void >) nativeFunctions[574];
				NativeHammer.CSavedObjects.__N.CSavedObjects_Create = (delegate* unmanaged< IntPtr >) nativeFunctions[575];
				NativeHammer.CSavedObjects.__N.CSavedObjects_RemoveAll = (delegate* unmanaged< IntPtr, void >) nativeFunctions[576];
				NativeHammer.CSavedObjects.__N.CSavedObjects_SaveObject = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[577];
				NativeHammer.CSavedObjects.__N.CSavedObjects_RestoreObjects = (delegate* unmanaged< IntPtr, void >) nativeFunctions[578];
				NativeHammer.CSavedObjects.__N.CSavedObjects_Count = (delegate* unmanaged< IntPtr, int >) nativeFunctions[579];
				NativeMapDoc.CSelection.__N.CSelection_GetMode = (delegate* unmanaged< IntPtr, long >) nativeFunctions[580];
				NativeMapDoc.CSelection.__N.CSelection_SetMode = (delegate* unmanaged< IntPtr, long, long, void >) nativeFunctions[581];
				NativeMapDoc.CSelection.__N.CSelection_ActiveSelectionSet = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[582];
				NativeMapDoc.CSelection.__N.CSelection_GetSelectionSetForMode = (delegate* unmanaged< IntPtr, long, IntPtr >) nativeFunctions[583];
				NativeMapDoc.CSelection.__N.CSelection_GetNumSelectionSets = (delegate* unmanaged< IntPtr, int >) nativeFunctions[584];
				NativeMapDoc.CSelection.__N.CSelection_GetSelectionSet = (delegate* unmanaged< IntPtr, int, IntPtr >) nativeFunctions[585];
				CToolBlock.__N.CToolBlock_OnObjectTypeChanged = (delegate* unmanaged< IntPtr, void >) nativeFunctions[586];
				CToolBlock.__N.CToolBlock_SetPrimitiveType2D = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[587];
				CToolBlock.__N.CToolBlock_GetOrientPrimitives = (delegate* unmanaged< IntPtr, int >) nativeFunctions[588];
				CToolBlock.__N.CToolBlock_SetOrientPrimitives = (delegate* unmanaged< IntPtr, int, void >) nativeFunctions[589];
				CToolBlock.__N.Get__CToolBlock_m_OverrideMaterial = (delegate* unmanaged[SuppressGCTransition]<IntPtr, IntPtr>)( nativeFunctions[590] );
				CToolBlock.__N.Set__CToolBlock_m_OverrideMaterial = (delegate* unmanaged[SuppressGCTransition]<IntPtr, IntPtr, void>)( nativeFunctions[591] );
				CToolBlockState.__N.CToolBlockState_GetAABBBounds = (delegate* unmanaged< IntPtr, BBox >) nativeFunctions[592];
				CToolBlockState.__N.CToolBlockState_GetDragWorkPlane = (delegate* unmanaged< IntPtr, IntPtr >) nativeFunctions[593];
				NativeHammer.CToolCamera.__N.CToolCamera_GetOrigin = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[594];
				NativeHammer.CToolCamera.__N.CToolCamera_GetAngles = (delegate* unmanaged< IntPtr, Angles >) nativeFunctions[595];
				NativeHammer.CToolCamera.__N.CToolCamera_SetOrigin = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[596];
				NativeHammer.CToolCamera.__N.CToolCamera_SetAngles = (delegate* unmanaged< IntPtr, Angles*, void >) nativeFunctions[597];
				NativeHammer.CToolCamera.__N.CToolCamera_GetWidth = (delegate* unmanaged< IntPtr, float >) nativeFunctions[598];
				NativeHammer.CToolCamera.__N.CToolCamera_GetHeight = (delegate* unmanaged< IntPtr, float >) nativeFunctions[599];
				NativeHammer.CToolCamera.__N.CToolCamera_GetCameraFOV = (delegate* unmanaged< IntPtr, float >) nativeFunctions[600];
				NativeHammer.CToolCamera.__N.CToolCamera_BuildRay = (delegate* unmanaged< IntPtr, Vector2*, out Vector3, out Vector3, void >) nativeFunctions[601];
				CToolEntity.__N.CToolEntity_StartBlockEntityCreation = (delegate* unmanaged< IntPtr, IntPtr, void >) nativeFunctions[602];
				CWorkPlane.__N.CWorkPlane_GetWorkPlaneToWorldTransform = (delegate* unmanaged< IntPtr, Matrix >) nativeFunctions[603];
				NativeHammer.Global.__N.global_MaterialGetMappingWidth = (delegate* unmanaged< IntPtr, int >) nativeFunctions[604];
				NativeHammer.Global.__N.global_MaterialGetMappingHeight = (delegate* unmanaged< IntPtr, int >) nativeFunctions[605];
				NativeMapDoc.ISelectionSet.__N.ISelectionSet_SelectObject = (delegate* unmanaged< IntPtr, IntPtr, long, int >) nativeFunctions[606];
				NativeMapDoc.ISelectionSet.__N.ISelectionSet_GetSelectedObject = (delegate* unmanaged< IntPtr, int, int >) nativeFunctions[607];
				NativeMapDoc.ISelectionSet.__N.ISelectionSet_Count = (delegate* unmanaged< IntPtr, int >) nativeFunctions[608];
				NativeMapDoc.ISelectionSet.__N.ISelectionSet_RemoveAll = (delegate* unmanaged< IntPtr, void >) nativeFunctions[609];
				NativeMapDoc.ISelectionSet.__N.ISelectionSet_SelectAll = (delegate* unmanaged< IntPtr, void >) nativeFunctions[610];
				NativeMapDoc.ISelectionSet.__N.ISelectionSet_InvertSelection = (delegate* unmanaged< IntPtr, void >) nativeFunctions[611];
				NativeMapDoc.ISelectionSet.__N.ISelectionSet_GetPivotPosition = (delegate* unmanaged< IntPtr, Vector3 >) nativeFunctions[612];
				NativeMapDoc.ISelectionSet.__N.ISelectionSet_SetPivot = (delegate* unmanaged< IntPtr, Vector3*, void >) nativeFunctions[613];
				NativeHammer.Options.__N.NativeHammer_Options_GetShowHelpers = (delegate* unmanaged< int >) nativeFunctions[614];
				NativeHammer.Options.__N.NativeHammer_Options_GetShowGameObjectsOnly = (delegate* unmanaged< int >) nativeFunctions[615];
			}
			catch ( System.Exception ___e )
			{
				onError( $"{___e.Message}\n\n{___e.StackTrace}" );
			}
			_initialized = true;
		}
		internal static void Free()
		{
			if ( _nativeLibraryHandle == IntPtr.Zero ) return;
			NativeLibrary.Free( _nativeLibraryHandle );
			_nativeLibraryHandle = IntPtr.Zero;
			_initialized = false;
		}
	}
}
